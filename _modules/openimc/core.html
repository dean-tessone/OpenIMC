

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>openimc.core &mdash; OpenIMC 0.1.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=e59714d7" />

  
      <script src="../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../_static/documentation_options.js?v=01f34227"></script>
      <script src="../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            OpenIMC
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">User Guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../overview.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../installation.html">Installation</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">API Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../api_core.html">Core pipeline API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api_cli.html">CLI API</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">OpenIMC</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">openimc.core</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for openimc.core</h1><div class="highlight"><pre>
<span></span><span class="c1"># SPDX-License-Identifier: GPL-3.0-or-later</span>
<span class="c1">#</span>
<span class="c1"># OpenIMC â€“ Interactive analysis toolkit for IMC data</span>
<span class="c1">#</span>
<span class="c1"># Copyright (C) 2025 University of Southern California</span>
<span class="c1">#</span>
<span class="c1"># This program is free software: you can redistribute it and/or modify</span>
<span class="c1"># it under the terms of the GNU General Public License as published by</span>
<span class="c1"># the Free Software Foundation, either version 3 of the License, or</span>
<span class="c1"># (at your option) any later version.</span>
<span class="c1">#</span>
<span class="c1"># This program is distributed in the hope that it will be useful,</span>
<span class="c1"># but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="c1"># MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="c1"># GNU General Public License for more details.</span>
<span class="c1">#</span>
<span class="c1"># You should have received a copy of the GNU General Public License</span>
<span class="c1"># along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Core operations for OpenIMC.</span>

<span class="sd">This module provides unified core operations that can be used by both</span>
<span class="sd">the GUI and CLI interfaces, ensuring exact parity between them.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">json</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">os</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pathlib</span><span class="w"> </span><span class="kn">import</span> <span class="n">Path</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">TYPE_CHECKING</span><span class="p">,</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Union</span>

<span class="k">if</span> <span class="n">TYPE_CHECKING</span><span class="p">:</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">anndata</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">ad</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pd</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">tifffile</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.spatial</span><span class="w"> </span><span class="kn">import</span> <span class="n">cKDTree</span><span class="p">,</span> <span class="n">Delaunay</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">openimc.data.mcd_loader</span><span class="w"> </span><span class="kn">import</span> <span class="n">MCDLoader</span><span class="p">,</span> <span class="n">AcquisitionInfo</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">openimc.data.ometiff_loader</span><span class="w"> </span><span class="kn">import</span> <span class="n">OMETIFFLoader</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">openimc.processing.export_worker</span><span class="w"> </span><span class="kn">import</span> <span class="n">process_channel_for_export</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">openimc.processing.feature_worker</span><span class="w"> </span><span class="kn">import</span> <span class="n">_apply_denoise_to_channel</span><span class="p">,</span> <span class="n">extract_features_for_acquisition</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">openimc.processing.watershed_worker</span><span class="w"> </span><span class="kn">import</span> <span class="n">watershed_segmentation</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">openimc.processing.batch_correction</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">apply_combat_correction</span><span class="p">,</span>
    <span class="n">apply_harmony_correction</span><span class="p">,</span>
    <span class="n">detect_batch_variable</span><span class="p">,</span>
    <span class="n">validate_batch_correction_inputs</span>
<span class="p">)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">openimc.processing.spillover_correction</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">load_spillover</span><span class="p">,</span>
    <span class="n">compensate_counts</span><span class="p">,</span>
    <span class="n">compensate_image_counts</span>
<span class="p">)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">openimc.processing.spillover_matrix</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">compute_spillmat</span><span class="p">,</span>
    <span class="n">adapt_spillmat</span><span class="p">,</span>
    <span class="n">build_spillover_from_comp_mcd</span>
<span class="p">)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">openimc.processing.deconvolution_worker</span><span class="w"> </span><span class="kn">import</span> <span class="n">RLD_HRIMC_circle</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">openimc.ui.utils</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">arcsinh_normalize</span><span class="p">,</span>
    <span class="n">percentile_clip_normalize</span><span class="p">,</span>
    <span class="n">channelwise_minmax_normalize</span><span class="p">,</span>
    <span class="n">combine_channels</span>
<span class="p">)</span>


<div class="viewcode-block" id="load_mcd">
<a class="viewcode-back" href="../../api_core.html#openimc.core.load_mcd">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">load_mcd</span><span class="p">(</span>
    <span class="n">input_path</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Path</span><span class="p">],</span>
    <span class="n">channel_format</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;CHW&#39;</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">MCDLoader</span><span class="p">,</span> <span class="n">OMETIFFLoader</span><span class="p">],</span> <span class="nb">str</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Load data from MCD file or OME-TIFF directory.</span>
<span class="sd">    </span>
<span class="sd">    This is the unified data loading function used by both GUI and CLI.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        input_path: Path to MCD file or OME-TIFF directory</span>
<span class="sd">        channel_format: Format for OME-TIFF files (&#39;CHW&#39; or &#39;HWC&#39;), default is &#39;CHW&#39;</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        Tuple of (loader, loader_type) where loader_type is &#39;mcd&#39; or &#39;ometiff&#39;</span>
<span class="sd">    </span>
<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If input path is invalid or unsupported format</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">input_path</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">input_path</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">input_path</span><span class="o">.</span><span class="n">is_file</span><span class="p">()</span> <span class="ow">and</span> <span class="n">input_path</span><span class="o">.</span><span class="n">suffix</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;.mcd&#39;</span><span class="p">,</span> <span class="s1">&#39;.mcdx&#39;</span><span class="p">]:</span>
        <span class="c1"># Load MCD file</span>
        <span class="n">loader</span> <span class="o">=</span> <span class="n">MCDLoader</span><span class="p">()</span>
        <span class="n">loader</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">input_path</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">loader</span><span class="p">,</span> <span class="s1">&#39;mcd&#39;</span>
    <span class="k">elif</span> <span class="n">input_path</span><span class="o">.</span><span class="n">is_dir</span><span class="p">():</span>
        <span class="c1"># Load OME-TIFF directory</span>
        <span class="n">loader</span> <span class="o">=</span> <span class="n">OMETIFFLoader</span><span class="p">(</span><span class="n">channel_format</span><span class="o">=</span><span class="n">channel_format</span><span class="p">)</span>
        <span class="n">loader</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">input_path</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">loader</span><span class="p">,</span> <span class="s1">&#39;ometiff&#39;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Input path must be an MCD file or directory containing OME-TIFF files: </span><span class="si">{</span><span class="n">input_path</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span></div>



<div class="viewcode-block" id="parse_denoise_settings">
<a class="viewcode-back" href="../../api_core.html#openimc.core.parse_denoise_settings">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">parse_denoise_settings</span><span class="p">(</span><span class="n">denoise_json</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Dict</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Parse denoise settings from JSON string, file, or dict.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        denoise_json: JSON string, path to JSON file, or dict with denoise settings</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        Dictionary with denoise settings per channel</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">denoise_json</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">{}</span>
    
    <span class="c1"># If already a dict, return as-is</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">denoise_json</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">denoise_json</span>
    
    <span class="c1"># Check if it&#39;s a file path</span>
    <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">denoise_json</span><span class="p">):</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">denoise_json</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">json</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
    
    <span class="c1"># Try to parse as JSON string</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">json</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">denoise_json</span><span class="p">)</span>
    <span class="k">except</span> <span class="n">json</span><span class="o">.</span><span class="n">JSONDecodeError</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid JSON for denoise settings: </span><span class="si">{</span><span class="n">denoise_json</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span></div>



<div class="viewcode-block" id="preprocess">
<a class="viewcode-back" href="../../api_core.html#openimc.core.preprocess">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">preprocess</span><span class="p">(</span>
    <span class="n">loader</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">MCDLoader</span><span class="p">,</span> <span class="n">OMETIFFLoader</span><span class="p">],</span>
    <span class="n">acquisition</span><span class="p">:</span> <span class="n">AcquisitionInfo</span><span class="p">,</span>
    <span class="n">output_dir</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Path</span><span class="p">],</span>
    <span class="n">denoise_settings</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">normalization_method</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;None&quot;</span><span class="p">,</span>
    <span class="n">arcsinh_cofactor</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">10.0</span><span class="p">,</span>
    <span class="n">percentile_params</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">99.0</span><span class="p">),</span>
    <span class="n">viewer_denoise_func</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">callable</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Path</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Preprocess a single acquisition: apply denoising and export to OME-TIFF.</span>
<span class="sd">    </span>
<span class="sd">    Note: arcsinh normalization is not applied to exported images by default.</span>
<span class="sd">    Only denoising is applied. Arcsinh transform should be applied on extracted intensity features.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        loader: MCDLoader or OMETIFFLoader instance</span>
<span class="sd">        acquisition: AcquisitionInfo for the acquisition to process</span>
<span class="sd">        output_dir: Directory to save the processed OME-TIFF file</span>
<span class="sd">        denoise_settings: Dictionary with denoise settings per channel (optional)</span>
<span class="sd">        normalization_method: Normalization method (&quot;None&quot;, &quot;arcsinh&quot;, &quot;percentile_clip&quot;, &quot;channelwise_minmax&quot;)</span>
<span class="sd">        arcsinh_cofactor: Arcsinh cofactor (only used if normalization_method is &quot;arcsinh&quot;)</span>
<span class="sd">        percentile_params: Tuple of (low, high) percentiles for percentile_clip normalization</span>
<span class="sd">        viewer_denoise_func: Optional function for viewer-based denoising (GUI only)</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        Path to the saved OME-TIFF file</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">output_dir</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">output_dir</span><span class="p">)</span>
    <span class="n">output_dir</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">parents</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    
    <span class="c1"># Get all channels</span>
    <span class="n">channels</span> <span class="o">=</span> <span class="n">loader</span><span class="o">.</span><span class="n">get_channels</span><span class="p">(</span><span class="n">acquisition</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
    <span class="n">img_stack</span> <span class="o">=</span> <span class="n">loader</span><span class="o">.</span><span class="n">get_all_channels</span><span class="p">(</span><span class="n">acquisition</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
    
    <span class="c1"># Process each channel</span>
    <span class="n">processed_channels</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">channel_name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">channels</span><span class="p">):</span>
        <span class="n">channel_img</span> <span class="o">=</span> <span class="n">img_stack</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="k">if</span> <span class="n">img_stack</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">3</span> <span class="k">else</span> <span class="n">img_stack</span>
        
        <span class="c1"># Apply denoising if configured</span>
        <span class="n">denoise_source</span> <span class="o">=</span> <span class="s2">&quot;custom&quot;</span> <span class="k">if</span> <span class="p">(</span><span class="n">denoise_settings</span> <span class="ow">and</span> <span class="n">channel_name</span> <span class="ow">in</span> <span class="n">denoise_settings</span><span class="p">)</span> <span class="k">else</span> <span class="s2">&quot;none&quot;</span>
        <span class="n">channel_denoise</span> <span class="o">=</span> <span class="n">denoise_settings</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">channel_name</span><span class="p">,</span> <span class="p">{})</span> <span class="k">if</span> <span class="n">denoise_settings</span> <span class="k">else</span> <span class="p">{}</span>
        
        <span class="c1"># Process channel - only denoising, no arcsinh normalization for export</span>
        <span class="c1"># Note: normalization_method is set to &quot;None&quot; for export to match CLI behavior</span>
        <span class="n">processed</span> <span class="o">=</span> <span class="n">process_channel_for_export</span><span class="p">(</span>
            <span class="n">channel_img</span><span class="p">,</span> <span class="n">channel_name</span><span class="p">,</span> <span class="n">denoise_source</span><span class="p">,</span>
            <span class="p">{</span><span class="n">channel_name</span><span class="p">:</span> <span class="n">channel_denoise</span><span class="p">}</span> <span class="k">if</span> <span class="n">channel_denoise</span> <span class="k">else</span> <span class="p">{},</span>
            <span class="n">normalization_method</span><span class="p">,</span>  <span class="c1"># Usually &quot;None&quot; for export</span>
            <span class="n">arcsinh_cofactor</span><span class="p">,</span>
            <span class="n">percentile_params</span><span class="p">,</span>
            <span class="n">viewer_denoise_func</span>  <span class="c1"># Only used in GUI</span>
        <span class="p">)</span>
        
        <span class="n">processed_channels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">processed</span><span class="p">)</span>
    
    <span class="c1"># Stack channels in CHW format (C, H, W) to match GUI export</span>
    <span class="n">processed_stack</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">processed_channels</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    
    <span class="c1"># Save as OME-TIFF</span>
    <span class="c1"># Use well name if available, otherwise use acquisition name</span>
    <span class="k">if</span> <span class="n">acquisition</span><span class="o">.</span><span class="n">well</span><span class="p">:</span>
        <span class="n">output_filename</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">acquisition</span><span class="o">.</span><span class="n">well</span><span class="si">}</span><span class="s2">.ome.tif&quot;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">output_filename</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">acquisition</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">.ome.tif&quot;</span>
    <span class="n">output_path</span> <span class="o">=</span> <span class="n">output_dir</span> <span class="o">/</span> <span class="n">output_filename</span>
    
    <span class="c1"># Create OME metadata</span>
    <span class="n">metadata</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;Channel&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;Name&#39;</span><span class="p">:</span> <span class="n">channels</span><span class="p">}</span>
    <span class="p">}</span>
    
    <span class="n">tifffile</span><span class="o">.</span><span class="n">imwrite</span><span class="p">(</span>
        <span class="nb">str</span><span class="p">(</span><span class="n">output_path</span><span class="p">),</span>
        <span class="n">processed_stack</span><span class="p">,</span>
        <span class="n">metadata</span><span class="o">=</span><span class="n">metadata</span><span class="p">,</span>
        <span class="n">ome</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">photometric</span><span class="o">=</span><span class="s1">&#39;minisblack&#39;</span>
    <span class="p">)</span>
    
    <span class="k">return</span> <span class="n">output_path</span></div>



<span class="k">def</span><span class="w"> </span><span class="nf">_ensure_0_1_range</span><span class="p">(</span><span class="n">img</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Ensure image is normalized to 0-1 range using min-max scaling.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        img: Input image</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        Image normalized to 0-1 range</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">img_float</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">vmin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">img_float</span><span class="p">)</span>
    <span class="n">vmax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">img_float</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">vmax</span> <span class="o">&gt;</span> <span class="n">vmin</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">img_float</span> <span class="o">-</span> <span class="n">vmin</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">vmax</span> <span class="o">-</span> <span class="n">vmin</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">img_float</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_preprocess_channels_for_segmentation</span><span class="p">(</span>
    <span class="n">loader</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">MCDLoader</span><span class="p">,</span> <span class="n">OMETIFFLoader</span><span class="p">],</span>
    <span class="n">acquisition</span><span class="p">:</span> <span class="n">AcquisitionInfo</span><span class="p">,</span>
    <span class="n">nuclear_channels</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
    <span class="n">cyto_channels</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
    <span class="n">denoise_settings</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">normalization_method</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;None&quot;</span><span class="p">,</span>
    <span class="n">arcsinh_cofactor</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">10.0</span><span class="p">,</span>
    <span class="n">percentile_params</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">99.0</span><span class="p">),</span>
    <span class="n">nuclear_combo_method</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;mean&quot;</span><span class="p">,</span>
    <span class="n">cyto_combo_method</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;mean&quot;</span><span class="p">,</span>
    <span class="n">nuclear_weights</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">cyto_weights</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Preprocess channels for segmentation: load, denoise, normalize, and combine.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        loader: MCDLoader or OMETIFFLoader instance</span>
<span class="sd">        acquisition: AcquisitionInfo for the acquisition</span>
<span class="sd">        nuclear_channels: List of nuclear channel names</span>
<span class="sd">        cyto_channels: List of cytoplasm channel names (can be empty)</span>
<span class="sd">        denoise_settings: Dictionary with denoise settings per channel (optional)</span>
<span class="sd">        normalization_method: Normalization method (&quot;None&quot;, &quot;arcsinh&quot;, &quot;percentile_clip&quot;, &quot;channelwise_minmax&quot;)</span>
<span class="sd">        arcsinh_cofactor: Arcsinh cofactor (only used if normalization_method is &quot;arcsinh&quot;)</span>
<span class="sd">        percentile_params: Tuple of (low, high) percentiles for percentile_clip normalization</span>
<span class="sd">        nuclear_combo_method: Method to combine nuclear channels (&quot;single&quot;, &quot;mean&quot;, &quot;weighted&quot;, &quot;max&quot;, &quot;pca1&quot;)</span>
<span class="sd">        cyto_combo_method: Method to combine cytoplasm channels</span>
<span class="sd">        nuclear_weights: Optional weights for nuclear channels (for weighted combination)</span>
<span class="sd">        cyto_weights: Optional weights for cytoplasm channels</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        Tuple of (nuclear_img, cyto_img) where cyto_img can be None</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Load and preprocess nuclear channels</span>
    <span class="n">nuclear_imgs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">channel</span> <span class="ow">in</span> <span class="n">nuclear_channels</span><span class="p">:</span>
        <span class="n">img</span> <span class="o">=</span> <span class="n">loader</span><span class="o">.</span><span class="n">get_image</span><span class="p">(</span><span class="n">acquisition</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">channel</span><span class="p">)</span>
        <span class="c1"># Apply denoising if custom settings provided</span>
        <span class="k">if</span> <span class="n">denoise_settings</span> <span class="ow">and</span> <span class="n">channel</span> <span class="ow">in</span> <span class="n">denoise_settings</span><span class="p">:</span>
            <span class="n">img</span> <span class="o">=</span> <span class="n">_apply_denoise_to_channel</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">channel</span><span class="p">,</span> <span class="n">denoise_settings</span><span class="p">[</span><span class="n">channel</span><span class="p">])</span>
        <span class="c1"># Apply normalization if configured</span>
        <span class="k">if</span> <span class="n">normalization_method</span> <span class="o">==</span> <span class="s1">&#39;channelwise_minmax&#39;</span><span class="p">:</span>
            <span class="n">img</span> <span class="o">=</span> <span class="n">channelwise_minmax_normalize</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">normalization_method</span> <span class="o">==</span> <span class="s1">&#39;arcsinh&#39;</span><span class="p">:</span>
            <span class="n">img</span> <span class="o">=</span> <span class="n">arcsinh_normalize</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">cofactor</span><span class="o">=</span><span class="n">arcsinh_cofactor</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">normalization_method</span> <span class="o">==</span> <span class="s1">&#39;percentile_clip&#39;</span><span class="p">:</span>
            <span class="n">p_low</span><span class="p">,</span> <span class="n">p_high</span> <span class="o">=</span> <span class="n">percentile_params</span>
            <span class="n">img</span> <span class="o">=</span> <span class="n">percentile_clip_normalize</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">p_low</span><span class="o">=</span><span class="n">p_low</span><span class="p">,</span> <span class="n">p_high</span><span class="o">=</span><span class="n">p_high</span><span class="p">)</span>
        <span class="c1"># Ensure 0-1 range after denoising and normalization</span>
        <span class="n">img</span> <span class="o">=</span> <span class="n">_ensure_0_1_range</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>
        <span class="n">nuclear_imgs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>
    
    <span class="c1"># Combine nuclear channels</span>
    <span class="n">nuclear_img</span> <span class="o">=</span> <span class="n">combine_channels</span><span class="p">(</span><span class="n">nuclear_imgs</span><span class="p">,</span> <span class="n">nuclear_combo_method</span><span class="p">,</span> <span class="n">nuclear_weights</span><span class="p">)</span>
    <span class="n">nuclear_img</span> <span class="o">=</span> <span class="n">_ensure_0_1_range</span><span class="p">(</span><span class="n">nuclear_img</span><span class="p">)</span>
    
    <span class="c1"># Load and preprocess cytoplasm channels</span>
    <span class="n">cyto_img</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">cyto_channels</span><span class="p">:</span>
        <span class="n">cyto_imgs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">channel</span> <span class="ow">in</span> <span class="n">cyto_channels</span><span class="p">:</span>
            <span class="n">img</span> <span class="o">=</span> <span class="n">loader</span><span class="o">.</span><span class="n">get_image</span><span class="p">(</span><span class="n">acquisition</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">channel</span><span class="p">)</span>
            <span class="c1"># Apply denoising if custom settings provided</span>
            <span class="k">if</span> <span class="n">denoise_settings</span> <span class="ow">and</span> <span class="n">channel</span> <span class="ow">in</span> <span class="n">denoise_settings</span><span class="p">:</span>
                <span class="n">img</span> <span class="o">=</span> <span class="n">_apply_denoise_to_channel</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">channel</span><span class="p">,</span> <span class="n">denoise_settings</span><span class="p">[</span><span class="n">channel</span><span class="p">])</span>
            <span class="c1"># Apply normalization if configured</span>
            <span class="k">if</span> <span class="n">normalization_method</span> <span class="o">==</span> <span class="s1">&#39;channelwise_minmax&#39;</span><span class="p">:</span>
                <span class="n">img</span> <span class="o">=</span> <span class="n">channelwise_minmax_normalize</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">normalization_method</span> <span class="o">==</span> <span class="s1">&#39;arcsinh&#39;</span><span class="p">:</span>
                <span class="n">img</span> <span class="o">=</span> <span class="n">arcsinh_normalize</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">cofactor</span><span class="o">=</span><span class="n">arcsinh_cofactor</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">normalization_method</span> <span class="o">==</span> <span class="s1">&#39;percentile_clip&#39;</span><span class="p">:</span>
                <span class="n">p_low</span><span class="p">,</span> <span class="n">p_high</span> <span class="o">=</span> <span class="n">percentile_params</span>
                <span class="n">img</span> <span class="o">=</span> <span class="n">percentile_clip_normalize</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">p_low</span><span class="o">=</span><span class="n">p_low</span><span class="p">,</span> <span class="n">p_high</span><span class="o">=</span><span class="n">p_high</span><span class="p">)</span>
            <span class="c1"># Ensure 0-1 range after denoising and normalization</span>
            <span class="n">img</span> <span class="o">=</span> <span class="n">_ensure_0_1_range</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>
            <span class="n">cyto_imgs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>
        
        <span class="c1"># Combine cytoplasm channels</span>
        <span class="n">cyto_img</span> <span class="o">=</span> <span class="n">combine_channels</span><span class="p">(</span><span class="n">cyto_imgs</span><span class="p">,</span> <span class="n">cyto_combo_method</span><span class="p">,</span> <span class="n">cyto_weights</span><span class="p">)</span>
        <span class="n">cyto_img</span> <span class="o">=</span> <span class="n">_ensure_0_1_range</span><span class="p">(</span><span class="n">cyto_img</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">nuclear_img</span><span class="p">,</span> <span class="n">cyto_img</span>


<div class="viewcode-block" id="segment">
<a class="viewcode-back" href="../../api_core.html#openimc.core.segment">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">segment</span><span class="p">(</span>
    <span class="n">loader</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">MCDLoader</span><span class="p">,</span> <span class="n">OMETIFFLoader</span><span class="p">],</span>
    <span class="n">acquisition</span><span class="p">:</span> <span class="n">AcquisitionInfo</span><span class="p">,</span>
    <span class="n">method</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">nuclear_channels</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
    <span class="n">cyto_channels</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">output_dir</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Path</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">denoise_settings</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">normalization_method</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;None&quot;</span><span class="p">,</span>
    <span class="n">arcsinh_cofactor</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">10.0</span><span class="p">,</span>
    <span class="n">percentile_params</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">99.0</span><span class="p">),</span>
    <span class="n">nuclear_combo_method</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;mean&quot;</span><span class="p">,</span>
    <span class="n">cyto_combo_method</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;mean&quot;</span><span class="p">,</span>
    <span class="n">nuclear_weights</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">cyto_weights</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="c1"># Cellpose parameters</span>
    <span class="n">cellpose_model</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;cyto3&quot;</span><span class="p">,</span>
    <span class="n">diameter</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">flow_threshold</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.4</span><span class="p">,</span>
    <span class="n">cellprob_threshold</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
    <span class="n">gpu_id</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="c1"># CellSAM parameters</span>
    <span class="n">deepcell_api_key</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">bbox_threshold</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.4</span><span class="p">,</span>
    <span class="n">use_wsi</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">low_contrast_enhancement</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">gauge_cell_size</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="c1"># Watershed parameters</span>
    <span class="n">min_cell_area</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span>
    <span class="n">max_cell_area</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10000</span><span class="p">,</span>
    <span class="n">compactness</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.01</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Segment cells using CellSAM, Cellpose, or Watershed method.</span>
<span class="sd">    </span>
<span class="sd">    This is the unified segmentation function used by both GUI and CLI.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        loader: MCDLoader or OMETIFFLoader instance</span>
<span class="sd">        acquisition: AcquisitionInfo for the acquisition to segment</span>
<span class="sd">        method: Segmentation method (&quot;cellsam&quot;, &quot;cellpose&quot;, or &quot;watershed&quot;)</span>
<span class="sd">        nuclear_channels: List of nuclear channel names (required)</span>
<span class="sd">        cyto_channels: List of cytoplasm channel names (optional, required for watershed and cyto3 model)</span>
<span class="sd">        output_dir: Optional directory to save mask (if None, mask is not saved)</span>
<span class="sd">        denoise_settings: Dictionary with denoise settings per channel (optional)</span>
<span class="sd">        normalization_method: Normalization method (&quot;None&quot;, &quot;arcsinh&quot;, &quot;percentile_clip&quot;, &quot;channelwise_minmax&quot;)</span>
<span class="sd">        arcsinh_cofactor: Arcsinh cofactor (only used if normalization_method is &quot;arcsinh&quot;)</span>
<span class="sd">        percentile_params: Tuple of (low, high) percentiles for percentile_clip normalization</span>
<span class="sd">        nuclear_combo_method: Method to combine nuclear channels</span>
<span class="sd">        cyto_combo_method: Method to combine cytoplasm channels</span>
<span class="sd">        nuclear_weights: Optional weights for nuclear channels</span>
<span class="sd">        cyto_weights: Optional weights for cytoplasm channels</span>
<span class="sd">        cellpose_model: Cellpose model type (&quot;cyto3&quot; or &quot;nuclei&quot;)</span>
<span class="sd">        diameter: Cell diameter in pixels (Cellpose, optional)</span>
<span class="sd">        flow_threshold: Flow threshold (Cellpose)</span>
<span class="sd">        cellprob_threshold: Cell probability threshold (Cellpose)</span>
<span class="sd">        gpu_id: GPU ID to use (Cellpose, optional)</span>
<span class="sd">        deepcell_api_key: DeepCell API key (CellSAM, optional, can use DEEPCELL_ACCESS_TOKEN env var)</span>
<span class="sd">        bbox_threshold: Bbox threshold for CellSAM</span>
<span class="sd">        use_wsi: Use WSI mode for CellSAM</span>
<span class="sd">        low_contrast_enhancement: Enable low contrast enhancement for CellSAM</span>
<span class="sd">        gauge_cell_size: Enable gauge cell size for CellSAM</span>
<span class="sd">        min_cell_area: Minimum cell area in pixels (watershed)</span>
<span class="sd">        max_cell_area: Maximum cell area in pixels (watershed)</span>
<span class="sd">        compactness: Watershed compactness</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        Segmentation mask as numpy array (uint32)</span>
<span class="sd">    </span>
<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If method is invalid or required channels are missing</span>
<span class="sd">        ImportError: If required dependencies are not installed</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">cyto_channels</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">cyto_channels</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="c1"># Validate channels</span>
    <span class="n">channels</span> <span class="o">=</span> <span class="n">loader</span><span class="o">.</span><span class="n">get_channels</span><span class="p">(</span><span class="n">acquisition</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
    <span class="n">missing_nuclear</span> <span class="o">=</span> <span class="p">[</span><span class="n">ch</span> <span class="k">for</span> <span class="n">ch</span> <span class="ow">in</span> <span class="n">nuclear_channels</span> <span class="k">if</span> <span class="n">ch</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">channels</span><span class="p">]</span>
    <span class="n">missing_cyto</span> <span class="o">=</span> <span class="p">[</span><span class="n">ch</span> <span class="k">for</span> <span class="n">ch</span> <span class="ow">in</span> <span class="n">cyto_channels</span> <span class="k">if</span> <span class="n">ch</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">channels</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">missing_nuclear</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Nuclear channels not found: </span><span class="si">{</span><span class="n">missing_nuclear</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">missing_cyto</span> <span class="ow">and</span> <span class="n">method</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;watershed&#39;</span><span class="p">,</span> <span class="s1">&#39;cellsam&#39;</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Cytoplasm channels not found: </span><span class="si">{</span><span class="n">missing_cyto</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;cellsam&#39;</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">nuclear_channels</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">cyto_channels</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;For CellSAM, at least one nuclear or cytoplasm channel must be specified&quot;</span><span class="p">)</span>
    
    <span class="c1"># Run segmentation based on method</span>
    <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;cellsam&#39;</span><span class="p">:</span>
        <span class="c1"># Try to import CellSAM</span>
        <span class="c1"># Catch both ImportError and OSError (Windows DLL loading errors)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="kn">from</span><span class="w"> </span><span class="nn">cellSAM</span><span class="w"> </span><span class="kn">import</span> <span class="n">get_model</span><span class="p">,</span> <span class="n">cellsam_pipeline</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">ImportError</span><span class="p">,</span> <span class="ne">OSError</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ImportError</span><span class="p">(</span><span class="s2">&quot;CellSAM not installed or failed to load. Install with: pip install git+https://github.com/vanvalenlab/cellSAM.git&quot;</span><span class="p">)</span>
        
        <span class="c1"># Set API key from argument or environment variable</span>
        <span class="n">api_key</span> <span class="o">=</span> <span class="n">deepcell_api_key</span> <span class="ow">or</span> <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;DEEPCELL_ACCESS_TOKEN&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">api_key</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;DeepCell API key is required for CellSAM. Set deepcell_api_key or DEEPCELL_ACCESS_TOKEN environment variable.&quot;</span><span class="p">)</span>
        <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="s2">&quot;DEEPCELL_ACCESS_TOKEN&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">api_key</span>
        
        <span class="c1"># Initialize CellSAM model and download weights</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">get_model</span><span class="p">()</span>  <span class="c1"># This downloads weights if not already present</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Failed to initialize CellSAM model: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">. Please check your API key and internet connection.&quot;</span><span class="p">)</span>
        
        <span class="c1"># Preprocess channels</span>
        <span class="n">nuclear_img</span><span class="p">,</span> <span class="n">cyto_img</span> <span class="o">=</span> <span class="n">_preprocess_channels_for_segmentation</span><span class="p">(</span>
            <span class="n">loader</span><span class="p">,</span> <span class="n">acquisition</span><span class="p">,</span> <span class="n">nuclear_channels</span><span class="p">,</span> <span class="n">cyto_channels</span><span class="p">,</span>
            <span class="n">denoise_settings</span><span class="p">,</span> <span class="n">normalization_method</span><span class="p">,</span> <span class="n">arcsinh_cofactor</span><span class="p">,</span>
            <span class="n">percentile_params</span><span class="p">,</span> <span class="n">nuclear_combo_method</span><span class="p">,</span> <span class="n">cyto_combo_method</span><span class="p">,</span>
            <span class="n">nuclear_weights</span><span class="p">,</span> <span class="n">cyto_weights</span>
        <span class="p">)</span>
        
        <span class="c1"># Prepare input for CellSAM (supports nuclear-only, cyto-only, or combined)</span>
        <span class="k">if</span> <span class="n">nuclear_channels</span> <span class="ow">and</span> <span class="n">cyto_channels</span><span class="p">:</span>
            <span class="c1"># Combined mode: H x W x 3 array</span>
            <span class="n">h</span><span class="p">,</span> <span class="n">w</span> <span class="o">=</span> <span class="n">nuclear_img</span><span class="o">.</span><span class="n">shape</span>
            <span class="n">cellsam_input</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">h</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
            <span class="n">cellsam_input</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">nuclear_img</span>  <span class="c1"># Channel 1 is nuclear</span>
            <span class="n">cellsam_input</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">cyto_img</span> <span class="k">if</span> <span class="n">cyto_img</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">nuclear_img</span>  <span class="c1"># Channel 2 is cyto</span>
        <span class="k">elif</span> <span class="n">nuclear_channels</span><span class="p">:</span>
            <span class="c1"># Nuclear only mode: H x W array</span>
            <span class="n">cellsam_input</span> <span class="o">=</span> <span class="n">nuclear_img</span>
        <span class="k">elif</span> <span class="n">cyto_channels</span><span class="p">:</span>
            <span class="c1"># Cyto only mode: H x W array</span>
            <span class="n">cellsam_input</span> <span class="o">=</span> <span class="n">cyto_img</span> <span class="k">if</span> <span class="n">cyto_img</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">nuclear_img</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;At least one channel (nuclear or cyto) must be selected for CellSAM&quot;</span><span class="p">)</span>
        
        <span class="c1"># Run CellSAM pipeline</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">cellsam_pipeline</span><span class="p">(</span>
            <span class="n">cellsam_input</span><span class="p">,</span>
            <span class="n">bbox_threshold</span><span class="o">=</span><span class="n">bbox_threshold</span><span class="p">,</span>
            <span class="n">use_wsi</span><span class="o">=</span><span class="n">use_wsi</span><span class="p">,</span>
            <span class="n">low_contrast_enhancement</span><span class="o">=</span><span class="n">low_contrast_enhancement</span><span class="p">,</span>
            <span class="n">gauge_cell_size</span><span class="o">=</span><span class="n">gauge_cell_size</span>
        <span class="p">)</span>
        <span class="c1"># Use mask directly without modifications</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">mask</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    
    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;cellpose&#39;</span><span class="p">:</span>
        <span class="c1"># Try to import Cellpose</span>
        <span class="c1"># Catch both ImportError and OSError (Windows DLL loading errors)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="kn">from</span><span class="w"> </span><span class="nn">cellpose</span><span class="w"> </span><span class="kn">import</span> <span class="n">models</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">ImportError</span><span class="p">,</span> <span class="ne">OSError</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ImportError</span><span class="p">(</span><span class="s2">&quot;Cellpose not installed or failed to load. Install with: pip install cellpose&quot;</span><span class="p">)</span>
        
        <span class="c1"># Preprocess channels</span>
        <span class="n">nuclear_img</span><span class="p">,</span> <span class="n">cyto_img</span> <span class="o">=</span> <span class="n">_preprocess_channels_for_segmentation</span><span class="p">(</span>
            <span class="n">loader</span><span class="p">,</span> <span class="n">acquisition</span><span class="p">,</span> <span class="n">nuclear_channels</span><span class="p">,</span> <span class="n">cyto_channels</span><span class="p">,</span>
            <span class="n">denoise_settings</span><span class="p">,</span> <span class="n">normalization_method</span><span class="p">,</span> <span class="n">arcsinh_cofactor</span><span class="p">,</span>
            <span class="n">percentile_params</span><span class="p">,</span> <span class="n">nuclear_combo_method</span><span class="p">,</span> <span class="n">cyto_combo_method</span><span class="p">,</span>
            <span class="n">nuclear_weights</span><span class="p">,</span> <span class="n">cyto_weights</span>
        <span class="p">)</span>
        
        <span class="c1"># Ensure images are in 0-1 range before passing to Cellpose</span>
        <span class="n">nuclear_img</span> <span class="o">=</span> <span class="n">_ensure_0_1_range</span><span class="p">(</span><span class="n">nuclear_img</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">cyto_img</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">cyto_img</span> <span class="o">=</span> <span class="n">_ensure_0_1_range</span><span class="p">(</span><span class="n">cyto_img</span><span class="p">)</span>
        
        <span class="c1"># Prepare input images for Cellpose</span>
        <span class="k">if</span> <span class="n">cellpose_model</span> <span class="o">==</span> <span class="s1">&#39;nuclei&#39;</span><span class="p">:</span>
            <span class="c1"># For nuclei model, use only nuclear channel</span>
            <span class="n">images</span> <span class="o">=</span> <span class="p">[</span><span class="n">nuclear_img</span><span class="p">]</span>
            <span class="n">channels_cp</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>  <span class="c1"># [cytoplasm, nucleus] - both are nuclear channel</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># cyto3</span>
            <span class="c1"># For cyto3 model, use both channels</span>
            <span class="k">if</span> <span class="n">cyto_img</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">cyto_img</span> <span class="o">=</span> <span class="n">nuclear_img</span>  <span class="c1"># Fallback to nuclear channel</span>
            <span class="n">images</span> <span class="o">=</span> <span class="p">[</span><span class="n">cyto_img</span><span class="p">,</span> <span class="n">nuclear_img</span><span class="p">]</span>
            <span class="n">channels_cp</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>  <span class="c1"># [cytoplasm, nucleus]</span>
        
        <span class="c1"># Initialize Cellpose model</span>
        <span class="n">use_gpu</span> <span class="o">=</span> <span class="n">gpu_id</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="n">model</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">Cellpose</span><span class="p">(</span><span class="n">model_type</span><span class="o">=</span><span class="n">cellpose_model</span><span class="p">,</span> <span class="n">gpu</span><span class="o">=</span><span class="n">use_gpu</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">gpu_id</span><span class="p">)</span>
        
        <span class="c1"># Run Cellpose</span>
        <span class="n">masks</span><span class="p">,</span> <span class="n">flows</span><span class="p">,</span> <span class="n">styles</span><span class="p">,</span> <span class="n">diams</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span>
            <span class="n">images</span><span class="p">,</span>
            <span class="n">diameter</span><span class="o">=</span><span class="n">diameter</span><span class="p">,</span>
            <span class="n">flow_threshold</span><span class="o">=</span><span class="n">flow_threshold</span><span class="p">,</span>
            <span class="n">cellprob_threshold</span><span class="o">=</span><span class="n">cellprob_threshold</span><span class="p">,</span>
            <span class="n">channels</span><span class="o">=</span><span class="n">channels_cp</span>
        <span class="p">)</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">masks</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    
    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;watershed&#39;</span><span class="p">:</span>
        <span class="c1"># Get image stack and channels for watershed</span>
        <span class="n">channels</span> <span class="o">=</span> <span class="n">loader</span><span class="o">.</span><span class="n">get_channels</span><span class="p">(</span><span class="n">acquisition</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
        <span class="n">img_stack</span> <span class="o">=</span> <span class="n">loader</span><span class="o">.</span><span class="n">get_all_channels</span><span class="p">(</span><span class="n">acquisition</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
        
        <span class="c1"># Run watershed segmentation</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">watershed_segmentation</span><span class="p">(</span>
            <span class="n">img_stack</span><span class="p">,</span> <span class="n">channels</span><span class="p">,</span> <span class="n">nuclear_channels</span><span class="p">,</span> <span class="n">cyto_channels</span><span class="p">,</span>
            <span class="n">denoise_settings</span><span class="o">=</span><span class="n">denoise_settings</span> <span class="k">if</span> <span class="n">denoise_settings</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">normalization_method</span><span class="o">=</span><span class="n">normalization_method</span><span class="p">,</span>
            <span class="n">arcsinh_cofactor</span><span class="o">=</span><span class="n">arcsinh_cofactor</span><span class="p">,</span>
            <span class="n">min_cell_area</span><span class="o">=</span><span class="n">min_cell_area</span><span class="p">,</span>
            <span class="n">max_cell_area</span><span class="o">=</span><span class="n">max_cell_area</span><span class="p">,</span>
            <span class="n">compactness</span><span class="o">=</span><span class="n">compactness</span>
        <span class="p">)</span>
    
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unknown segmentation method: </span><span class="si">{</span><span class="n">method</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="c1"># Save mask if output directory is provided</span>
    <span class="k">if</span> <span class="n">output_dir</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">output_dir</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">output_dir</span><span class="p">)</span>
        <span class="n">output_dir</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">parents</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        
        <span class="c1"># Use well name if available, otherwise use acquisition name</span>
        <span class="k">if</span> <span class="n">acquisition</span><span class="o">.</span><span class="n">well</span><span class="p">:</span>
            <span class="n">output_filename</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">acquisition</span><span class="o">.</span><span class="n">well</span><span class="si">}</span><span class="s2">_segmentation.tif&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">output_filename</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">acquisition</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">_segmentation.tif&quot;</span>
        <span class="n">output_path</span> <span class="o">=</span> <span class="n">output_dir</span> <span class="o">/</span> <span class="n">output_filename</span>
        
        <span class="n">tifffile</span><span class="o">.</span><span class="n">imwrite</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">output_path</span><span class="p">),</span> <span class="n">mask</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint32</span><span class="p">),</span> <span class="n">compression</span><span class="o">=</span><span class="s1">&#39;lzw&#39;</span><span class="p">)</span>
        
        <span class="c1"># Also save as numpy array for easier loading</span>
        <span class="n">np</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">output_path</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;.tif&#39;</span><span class="p">,</span> <span class="s1">&#39;.npy&#39;</span><span class="p">),</span> <span class="n">mask</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">mask</span></div>



<span class="k">def</span><span class="w"> </span><span class="nf">_load_masks_for_acquisitions</span><span class="p">(</span>
    <span class="n">mask_path</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Path</span><span class="p">],</span>
    <span class="n">acquisitions</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">AcquisitionInfo</span><span class="p">]</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Load segmentation masks for acquisitions.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        mask_path: Path to mask directory or single mask file</span>
<span class="sd">        acquisitions: List of AcquisitionInfo objects</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        Dictionary mapping acquisition ID to mask array</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">mask_path</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">mask_path</span><span class="p">)</span>
    <span class="n">masks_dict</span> <span class="o">=</span> <span class="p">{}</span>
    
    <span class="k">if</span> <span class="n">mask_path</span><span class="o">.</span><span class="n">is_dir</span><span class="p">():</span>
        <span class="c1"># Directory of masks - load masks for each acquisition</span>
        <span class="k">for</span> <span class="n">mask_file</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">mask_path</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="s1">&#39;*.tif&#39;</span><span class="p">))</span> <span class="o">+</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">mask_path</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="s1">&#39;*.tiff&#39;</span><span class="p">))</span> <span class="o">+</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">mask_path</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="s1">&#39;*.npy&#39;</span><span class="p">)):</span>
            <span class="c1"># Try to match mask filename to acquisition</span>
            <span class="c1"># First try well name, then fall back to acquisition name</span>
            <span class="n">mask_name</span> <span class="o">=</span> <span class="n">mask_file</span><span class="o">.</span><span class="n">stem</span>
            <span class="n">matched</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="c1"># Try to find matching acquisition by well name first</span>
            <span class="k">for</span> <span class="n">acq</span> <span class="ow">in</span> <span class="n">acquisitions</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">acq</span><span class="o">.</span><span class="n">well</span> <span class="ow">and</span> <span class="n">acq</span><span class="o">.</span><span class="n">well</span> <span class="ow">in</span> <span class="n">mask_name</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">mask_file</span><span class="o">.</span><span class="n">suffix</span> <span class="o">==</span> <span class="s1">&#39;.npy&#39;</span><span class="p">:</span>
                        <span class="n">masks_dict</span><span class="p">[</span><span class="n">acq</span><span class="o">.</span><span class="n">id</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">mask_file</span><span class="p">))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">masks_dict</span><span class="p">[</span><span class="n">acq</span><span class="o">.</span><span class="n">id</span><span class="p">]</span> <span class="o">=</span> <span class="n">tifffile</span><span class="o">.</span><span class="n">imread</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">mask_file</span><span class="p">))</span>
                    <span class="n">matched</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">break</span>
            
            <span class="c1"># If no match by well name, try acquisition name</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">matched</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">acq</span> <span class="ow">in</span> <span class="n">acquisitions</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">acq</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="n">mask_name</span> <span class="ow">or</span> <span class="n">acq</span><span class="o">.</span><span class="n">id</span> <span class="ow">in</span> <span class="n">mask_name</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">mask_file</span><span class="o">.</span><span class="n">suffix</span> <span class="o">==</span> <span class="s1">&#39;.npy&#39;</span><span class="p">:</span>
                            <span class="n">masks_dict</span><span class="p">[</span><span class="n">acq</span><span class="o">.</span><span class="n">id</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">mask_file</span><span class="p">))</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">masks_dict</span><span class="p">[</span><span class="n">acq</span><span class="o">.</span><span class="n">id</span><span class="p">]</span> <span class="o">=</span> <span class="n">tifffile</span><span class="o">.</span><span class="n">imread</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">mask_file</span><span class="p">))</span>
                        <span class="k">break</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Single mask file - use for all acquisitions</span>
        <span class="k">if</span> <span class="n">mask_path</span><span class="o">.</span><span class="n">suffix</span> <span class="o">==</span> <span class="s1">&#39;.npy&#39;</span><span class="p">:</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">mask_path</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">tifffile</span><span class="o">.</span><span class="n">imread</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">mask_path</span><span class="p">))</span>
        <span class="c1"># Use same mask for all acquisitions</span>
        <span class="k">for</span> <span class="n">acq</span> <span class="ow">in</span> <span class="n">acquisitions</span><span class="p">:</span>
            <span class="n">masks_dict</span><span class="p">[</span><span class="n">acq</span><span class="o">.</span><span class="n">id</span><span class="p">]</span> <span class="o">=</span> <span class="n">mask</span>
    
    <span class="k">return</span> <span class="n">masks_dict</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_build_feature_selection_dict</span><span class="p">(</span>
    <span class="n">morphological</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">intensity</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Build feature selection dictionary.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        morphological: Whether to include morphological features</span>
<span class="sd">        intensity: Whether to include intensity features</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        Dictionary mapping feature names to True/False</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">selected_features</span> <span class="o">=</span> <span class="p">{}</span>
    
    <span class="k">if</span> <span class="n">morphological</span><span class="p">:</span>
        <span class="c1"># Add all morphological features</span>
        <span class="n">selected_features</span><span class="o">.</span><span class="n">update</span><span class="p">({</span>
            <span class="s1">&#39;area_um2&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
            <span class="s1">&#39;perimeter_um&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
            <span class="s1">&#39;equivalent_diameter_um&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
            <span class="s1">&#39;eccentricity&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
            <span class="s1">&#39;solidity&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
            <span class="s1">&#39;extent&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
            <span class="s1">&#39;circularity&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
            <span class="s1">&#39;major_axis_len_um&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
            <span class="s1">&#39;minor_axis_len_um&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
            <span class="s1">&#39;aspect_ratio&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
            <span class="s1">&#39;bbox_area_um2&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
            <span class="s1">&#39;touches_border&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
            <span class="s1">&#39;holes_count&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
            <span class="s1">&#39;centroid_x&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
            <span class="s1">&#39;centroid_y&#39;</span><span class="p">:</span> <span class="kc">True</span>
        <span class="p">})</span>
    
    <span class="k">if</span> <span class="n">intensity</span><span class="p">:</span>
        <span class="c1"># Add all intensity features</span>
        <span class="n">selected_features</span><span class="o">.</span><span class="n">update</span><span class="p">({</span>
            <span class="s1">&#39;mean&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
            <span class="s1">&#39;median&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
            <span class="s1">&#39;std&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
            <span class="s1">&#39;mad&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
            <span class="s1">&#39;p10&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
            <span class="s1">&#39;p90&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
            <span class="s1">&#39;integrated&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
            <span class="s1">&#39;frac_pos&#39;</span><span class="p">:</span> <span class="kc">True</span>
        <span class="p">})</span>
    
    <span class="k">return</span> <span class="n">selected_features</span>


<div class="viewcode-block" id="extract_features">
<a class="viewcode-back" href="../../api_core.html#openimc.core.extract_features">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">extract_features</span><span class="p">(</span>
    <span class="n">loader</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">MCDLoader</span><span class="p">,</span> <span class="n">OMETIFFLoader</span><span class="p">],</span>
    <span class="n">acquisitions</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">AcquisitionInfo</span><span class="p">],</span>
    <span class="n">mask_path</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Path</span><span class="p">],</span>
    <span class="n">output_path</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Path</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">morphological</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">intensity</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">denoise_settings</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">arcsinh</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">arcsinh_cofactor</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">10.0</span><span class="p">,</span>
    <span class="n">spillover_config</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">excluded_channels</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">set</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">selected_features</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Extract features from segmented cells.</span>
<span class="sd">    </span>
<span class="sd">    This is the unified feature extraction function used by both GUI and CLI.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        loader: MCDLoader or OMETIFFLoader instance</span>
<span class="sd">        acquisitions: List of AcquisitionInfo objects to process</span>
<span class="sd">        mask_path: Path to mask directory or single mask file</span>
<span class="sd">        output_path: Optional path to save CSV (if None, features are not saved)</span>
<span class="sd">        morphological: Whether to extract morphological features</span>
<span class="sd">        intensity: Whether to extract intensity features</span>
<span class="sd">        denoise_settings: Dictionary with denoise settings per channel (optional)</span>
<span class="sd">        arcsinh: Whether to apply arcsinh transformation to intensity features</span>
<span class="sd">        arcsinh_cofactor: Arcsinh cofactor</span>
<span class="sd">        spillover_config: Optional spillover correction configuration</span>
<span class="sd">        excluded_channels: Optional set of channel names to exclude</span>
<span class="sd">        selected_features: Optional custom feature selection dict (overrides morphological/intensity)</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        DataFrame with extracted features</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Load masks</span>
    <span class="n">masks_dict</span> <span class="o">=</span> <span class="n">_load_masks_for_acquisitions</span><span class="p">(</span><span class="n">mask_path</span><span class="p">,</span> <span class="n">acquisitions</span><span class="p">)</span>
    
    <span class="c1"># Build feature selection dict</span>
    <span class="k">if</span> <span class="n">selected_features</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">selected_features</span> <span class="o">=</span> <span class="n">_build_feature_selection_dict</span><span class="p">(</span><span class="n">morphological</span><span class="p">,</span> <span class="n">intensity</span><span class="p">)</span>
    
    <span class="n">all_features</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="k">for</span> <span class="n">acq</span> <span class="ow">in</span> <span class="n">acquisitions</span><span class="p">:</span>
        <span class="c1"># Get mask for this acquisition</span>
        <span class="k">if</span> <span class="n">acq</span><span class="o">.</span><span class="n">id</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">masks_dict</span><span class="p">:</span>
            <span class="k">continue</span>
        
        <span class="n">mask</span> <span class="o">=</span> <span class="n">masks_dict</span><span class="p">[</span><span class="n">acq</span><span class="o">.</span><span class="n">id</span><span class="p">]</span>
        <span class="n">channels</span> <span class="o">=</span> <span class="n">loader</span><span class="o">.</span><span class="n">get_channels</span><span class="p">(</span><span class="n">acq</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
        <span class="n">img_stack</span> <span class="o">=</span> <span class="n">loader</span><span class="o">.</span><span class="n">get_all_channels</span><span class="p">(</span><span class="n">acq</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
        
        <span class="c1"># Prepare acquisition info</span>
        <span class="n">acq_info</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;channels&#39;</span><span class="p">:</span> <span class="n">channels</span><span class="p">,</span>
            <span class="s1">&#39;channel_metals&#39;</span><span class="p">:</span> <span class="n">acq</span><span class="o">.</span><span class="n">channel_metals</span><span class="p">,</span>
            <span class="s1">&#39;channel_labels&#39;</span><span class="p">:</span> <span class="n">acq</span><span class="o">.</span><span class="n">channel_labels</span><span class="p">,</span>
            <span class="s1">&#39;well&#39;</span><span class="p">:</span> <span class="n">acq</span><span class="o">.</span><span class="n">well</span>  <span class="c1"># Include well for source_well column creation</span>
        <span class="p">}</span>
        
        <span class="c1"># Extract features</span>
        <span class="c1"># Use well name for acquisition label if available, otherwise use acquisition name</span>
        <span class="n">acq_label</span> <span class="o">=</span> <span class="n">acq</span><span class="o">.</span><span class="n">well</span> <span class="k">if</span> <span class="n">acq</span><span class="o">.</span><span class="n">well</span> <span class="k">else</span> <span class="n">acq</span><span class="o">.</span><span class="n">name</span>
        <span class="n">features_df</span> <span class="o">=</span> <span class="n">extract_features_for_acquisition</span><span class="p">(</span>
            <span class="n">acq</span><span class="o">.</span><span class="n">id</span><span class="p">,</span>
            <span class="n">mask</span><span class="p">,</span>
            <span class="n">selected_features</span><span class="p">,</span>
            <span class="n">acq_info</span><span class="p">,</span>
            <span class="n">acq_label</span><span class="p">,</span>
            <span class="n">img_stack</span><span class="p">,</span>
            <span class="n">arcsinh</span><span class="p">,</span>
            <span class="n">arcsinh_cofactor</span><span class="p">,</span>
            <span class="s2">&quot;custom&quot;</span> <span class="k">if</span> <span class="n">denoise_settings</span> <span class="k">else</span> <span class="s2">&quot;None&quot;</span><span class="p">,</span>
            <span class="n">denoise_settings</span><span class="p">,</span>
            <span class="n">spillover_config</span><span class="p">,</span>
            <span class="n">acq</span><span class="o">.</span><span class="n">source_file</span><span class="p">,</span>
            <span class="n">excluded_channels</span>
        <span class="p">)</span>
        
        <span class="c1"># Add acquisition info</span>
        <span class="n">features_df</span><span class="p">[</span><span class="s1">&#39;acquisition_id&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">acq</span><span class="o">.</span><span class="n">id</span>
        <span class="n">features_df</span><span class="p">[</span><span class="s1">&#39;acquisition_name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">acq</span><span class="o">.</span><span class="n">name</span>
        <span class="k">if</span> <span class="n">acq</span><span class="o">.</span><span class="n">well</span><span class="p">:</span>
            <span class="n">features_df</span><span class="p">[</span><span class="s1">&#39;well&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">acq</span><span class="o">.</span><span class="n">well</span>
        
        <span class="n">all_features</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">features_df</span><span class="p">)</span>
    
    <span class="c1"># Combine all features</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_features</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">combined_features</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">all_features</span><span class="p">,</span> <span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_features</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">combined_features</span> <span class="o">=</span> <span class="n">all_features</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># No features extracted</span>
        <span class="n">combined_features</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
    
    <span class="c1"># Save to CSV if output path is provided</span>
    <span class="k">if</span> <span class="n">output_path</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">output_path</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">output_path</span><span class="p">)</span>
        <span class="n">combined_features</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">output_path</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">combined_features</span></div>



<div class="viewcode-block" id="cluster">
<a class="viewcode-back" href="../../api_core.html#openimc.core.cluster">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">cluster</span><span class="p">(</span>
    <span class="n">features_df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
    <span class="n">method</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;leiden&quot;</span><span class="p">,</span>
    <span class="n">columns</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">scaling</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;zscore&quot;</span><span class="p">,</span>
    <span class="n">output_path</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Path</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="c1"># Hierarchical parameters</span>
    <span class="n">n_clusters</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">linkage</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;ward&quot;</span><span class="p">,</span>
    <span class="c1"># Leiden/Louvain parameters</span>
    <span class="n">resolution</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
    <span class="n">seed</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">42</span><span class="p">,</span>
    <span class="n">n_neighbors</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">15</span><span class="p">,</span>  <span class="c1"># Number of neighbors for k-NN graph</span>
    <span class="n">metric</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;euclidean&quot;</span><span class="p">,</span>  <span class="c1"># Distance metric for k-NN graph</span>
    <span class="c1"># K-means parameters</span>
    <span class="n">n_init</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>  <span class="c1"># Number of initializations for K-means</span>
    <span class="c1"># HDBSCAN parameters</span>
    <span class="n">min_cluster_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
    <span class="n">min_samples</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
    <span class="n">cluster_selection_method</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;eom&quot;</span><span class="p">,</span>  <span class="c1"># HDBSCAN cluster selection method</span>
    <span class="n">hdbscan_metric</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;euclidean&quot;</span>  <span class="c1"># HDBSCAN distance metric</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Perform clustering on feature data.</span>
<span class="sd">    </span>
<span class="sd">    This is the unified clustering function used by both GUI and CLI.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        features_df: DataFrame with features to cluster</span>
<span class="sd">        method: Clustering method (&quot;hierarchical&quot;, &quot;leiden&quot;, &quot;louvain&quot;, &quot;kmeans&quot;, or &quot;hdbscan&quot;)</span>
<span class="sd">        columns: List of column names to use for clustering (auto-detect if None)</span>
<span class="sd">        scaling: Scaling method (&quot;none&quot;, &quot;zscore&quot;, or &quot;mad&quot;)</span>
<span class="sd">        output_path: Optional path to save clustered features CSV</span>
<span class="sd">        n_clusters: Number of clusters (required for hierarchical)</span>
<span class="sd">        linkage: Linkage method for hierarchical clustering (&quot;ward&quot;, &quot;complete&quot;, &quot;average&quot;)</span>
<span class="sd">        resolution: Resolution parameter for Leiden clustering</span>
<span class="sd">        seed: Random seed for reproducibility</span>
<span class="sd">        n_neighbors: Number of neighbors for k-NN graph construction (Leiden/Louvain only, default: 15)</span>
<span class="sd">        metric: Distance metric for k-NN graph (Leiden/Louvain only, default: &quot;euclidean&quot;)</span>
<span class="sd">        n_init: Number of initializations for K-means (default: 10)</span>
<span class="sd">        min_cluster_size: Minimum cluster size for HDBSCAN (default: 10)</span>
<span class="sd">        min_samples: Minimum samples for HDBSCAN (default: 5)</span>
<span class="sd">        cluster_selection_method: Cluster selection method for HDBSCAN (&quot;eom&quot; or &quot;leaf&quot;, default: &quot;eom&quot;)</span>
<span class="sd">        hdbscan_metric: Distance metric for HDBSCAN (default: &quot;euclidean&quot;)</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        DataFrame with cluster labels added in &#39;cluster&#39; column</span>
<span class="sd">    </span>
<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If method is invalid or required parameters are missing</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">time</span>
    <span class="n">t_start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[CORE.CLUSTER] Starting clustering: method=</span><span class="si">{</span><span class="n">method</span><span class="si">}</span><span class="s2">, input shape=</span><span class="si">{</span><span class="n">features_df</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="c1"># Select columns for clustering</span>
    <span class="n">t0</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">columns</span><span class="p">:</span>
        <span class="n">cluster_columns</span> <span class="o">=</span> <span class="n">columns</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Auto-detect: exclude non-feature columns (matching GUI)</span>
        <span class="n">exclude_cols</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;label&#39;</span><span class="p">,</span> <span class="s1">&#39;acquisition_id&#39;</span><span class="p">,</span> <span class="s1">&#39;acquisition_name&#39;</span><span class="p">,</span> <span class="s1">&#39;well&#39;</span><span class="p">,</span> <span class="s1">&#39;cluster&#39;</span><span class="p">,</span> <span class="s1">&#39;cell_id&#39;</span><span class="p">,</span>
                       <span class="s1">&#39;source_file&#39;</span><span class="p">,</span> <span class="s1">&#39;source_well&#39;</span><span class="p">,</span> <span class="s1">&#39;acquisition_label&#39;</span><span class="p">}</span>
        <span class="n">cluster_columns</span> <span class="o">=</span> <span class="p">[</span><span class="n">col</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">features_df</span><span class="o">.</span><span class="n">columns</span> <span class="k">if</span> <span class="n">col</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">exclude_cols</span><span class="p">]</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[CORE.CLUSTER] Column selection: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">cluster_columns</span><span class="p">)</span><span class="si">}</span><span class="s2"> columns, took </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">t0</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2">s&quot;</span><span class="p">)</span>
    
    <span class="c1"># Validate columns</span>
    <span class="n">missing</span> <span class="o">=</span> <span class="p">[</span><span class="n">col</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">cluster_columns</span> <span class="k">if</span> <span class="n">col</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">features_df</span><span class="o">.</span><span class="n">columns</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">missing</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Columns not found: </span><span class="si">{</span><span class="n">missing</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="c1"># Prepare data exactly like GUI _prepare_clustering_data</span>
    <span class="n">t0</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">features_df</span><span class="p">[</span><span class="n">cluster_columns</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[CORE.CLUSTER] Data copy: shape=</span><span class="si">{</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">, took </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">t0</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2">s&quot;</span><span class="p">)</span>
    
    <span class="c1"># Handle missing/infinite values safely (matching GUI)</span>
    <span class="n">t0</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">replace</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">numeric_only</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[CORE.CLUSTER] Handle missing/infinite: took </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">t0</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2">s&quot;</span><span class="p">)</span>
    
    <span class="c1"># Apply scaling (matching GUI _apply_scaling)</span>
    <span class="n">t0</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">scaling</span> <span class="o">==</span> <span class="s1">&#39;zscore&#39;</span><span class="p">:</span>
        <span class="c1"># Z-score normalization: (x - mean) / std</span>
        <span class="n">data_means</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
        <span class="n">data_stds</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">ddof</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        
        <span class="c1"># Handle columns with zero variance or NaN std/mean</span>
        <span class="n">zero_var_cols</span> <span class="o">=</span> <span class="p">(</span><span class="n">data_stds</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">|</span> <span class="n">data_stds</span><span class="o">.</span><span class="n">isna</span><span class="p">()</span> <span class="o">|</span> <span class="n">data_means</span><span class="o">.</span><span class="n">isna</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">zero_var_cols</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="c1"># Set zero variance/NaN columns to 0 (centered but not scaled)</span>
            <span class="n">data</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="n">zero_var_cols</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">non_zero_var_cols</span> <span class="o">=</span> <span class="o">~</span><span class="n">zero_var_cols</span>
            <span class="k">if</span> <span class="n">non_zero_var_cols</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                <span class="n">normalized_data</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="n">non_zero_var_cols</span><span class="p">]</span> <span class="o">-</span> <span class="n">data_means</span><span class="p">[</span><span class="n">non_zero_var_cols</span><span class="p">])</span> <span class="o">/</span> <span class="n">data_stds</span><span class="p">[</span><span class="n">non_zero_var_cols</span><span class="p">]</span>
                <span class="n">data</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="n">non_zero_var_cols</span><span class="p">]</span> <span class="o">=</span> <span class="n">normalized_data</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Normalize all columns</span>
            <span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span> <span class="o">-</span> <span class="n">data_means</span><span class="p">)</span> <span class="o">/</span> <span class="n">data_stds</span>
    <span class="k">elif</span> <span class="n">scaling</span> <span class="o">==</span> <span class="s1">&#39;mad&#39;</span><span class="p">:</span>
        <span class="c1"># MAD (Median Absolute Deviation) scaling: (x - median) / MAD</span>
        <span class="n">data_medians</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">median</span><span class="p">()</span>
        
        <span class="c1"># Calculate MAD for each column</span>
        <span class="n">mad_values</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="n">col_data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">col</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
            <span class="n">median_val</span> <span class="o">=</span> <span class="n">data_medians</span><span class="p">[</span><span class="n">col</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">pd</span><span class="o">.</span><span class="n">isna</span><span class="p">(</span><span class="n">median_val</span><span class="p">):</span>
                <span class="n">mad_values</span><span class="p">[</span><span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">mad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">col_data</span> <span class="o">-</span> <span class="n">median_val</span><span class="p">))</span>
                <span class="n">mad_values</span><span class="p">[</span><span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span> <span class="k">if</span> <span class="n">pd</span><span class="o">.</span><span class="n">isna</span><span class="p">(</span><span class="n">mad</span><span class="p">)</span> <span class="k">else</span> <span class="n">mad</span>
        
        <span class="n">mad_series</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">mad_values</span><span class="p">)</span>
        
        <span class="c1"># Handle columns with zero MAD or NaN</span>
        <span class="n">zero_mad_cols</span> <span class="o">=</span> <span class="p">(</span><span class="n">mad_series</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">|</span> <span class="n">mad_series</span><span class="o">.</span><span class="n">isna</span><span class="p">()</span> <span class="o">|</span> <span class="n">data_medians</span><span class="o">.</span><span class="n">isna</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">zero_mad_cols</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="n">data</span><span class="o">.</span><span class="n">loc</span><span class="p">[:,</span> <span class="n">zero_mad_cols</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">non_zero_mad_cols</span> <span class="o">=</span> <span class="o">~</span><span class="n">zero_mad_cols</span>
            <span class="k">if</span> <span class="n">non_zero_mad_cols</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="n">non_zero_mad_cols</span><span class="p">]:</span>
                    <span class="n">data</span><span class="p">[</span><span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">col</span><span class="p">]</span> <span class="o">-</span> <span class="n">data_medians</span><span class="p">[</span><span class="n">col</span><span class="p">])</span> <span class="o">/</span> <span class="n">mad_series</span><span class="p">[</span><span class="n">col</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                <span class="n">data</span><span class="p">[</span><span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">col</span><span class="p">]</span> <span class="o">-</span> <span class="n">data_medians</span><span class="p">[</span><span class="n">col</span><span class="p">])</span> <span class="o">/</span> <span class="n">mad_series</span><span class="p">[</span><span class="n">col</span><span class="p">]</span>
    <span class="c1"># If scaling == &#39;none&#39;, skip scaling</span>
    
    <span class="c1"># Handle any infinities that might have been introduced</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">replace</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[CORE.CLUSTER] Scaling complete: took </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">t0</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2">s&quot;</span><span class="p">)</span>
    
    <span class="c1"># Drop any residual non-finite rows/cols (matching GUI)</span>
    <span class="n">t0</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">dropna</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s1">&#39;any&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">dropna</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s1">&#39;any&#39;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[CORE.CLUSTER] Dropna: shape=</span><span class="si">{</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">, took </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">t0</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2">s&quot;</span><span class="p">)</span>
    
    <span class="c1"># Guard: require at least 2 rows and 2 columns</span>
    <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="ow">or</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Insufficient data for clustering. Need at least 2 rows and 2 columns after cleaning.&quot;</span><span class="p">)</span>
    
    <span class="c1"># Store original indices to map back</span>
    <span class="n">original_indices</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">index</span>
    <span class="n">data_values</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">values</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[CORE.CLUSTER] Final data shape: </span><span class="si">{</span><span class="n">data_values</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2"> (n_cells=</span><span class="si">{</span><span class="n">data_values</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">, n_features=</span><span class="si">{</span><span class="n">data_values</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
    
    <span class="c1"># Perform clustering</span>
    <span class="n">t_cluster_start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;hierarchical&#39;</span><span class="p">:</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">scipy.cluster.hierarchy</span><span class="w"> </span><span class="kn">import</span> <span class="n">linkage</span> <span class="k">as</span> <span class="n">scipy_linkage</span><span class="p">,</span> <span class="n">fcluster</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">scipy.spatial.distance</span><span class="w"> </span><span class="kn">import</span> <span class="n">pdist</span>
        
        <span class="n">n</span> <span class="o">=</span> <span class="n">data_values</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[CORE.CLUSTER] Hierarchical: Starting with </span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s2"> cells, linkage=</span><span class="si">{</span><span class="n">linkage</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
        <span class="n">t0</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="c1"># Calculate distance matrix (efficient condensed form)</span>
        <span class="n">distances</span> <span class="o">=</span> <span class="n">pdist</span><span class="p">(</span><span class="n">data_values</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="s1">&#39;euclidean&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[CORE.CLUSTER] Hierarchical: pdist took </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">t0</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2">s (distance array size: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">distances</span><span class="p">)</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
        
        <span class="n">t0</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="c1"># Perform linkage</span>
        <span class="n">linkage_matrix</span> <span class="o">=</span> <span class="n">scipy_linkage</span><span class="p">(</span><span class="n">distances</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">linkage</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[CORE.CLUSTER] Hierarchical: linkage took </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">t0</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2">s&quot;</span><span class="p">)</span>
        
        <span class="c1"># Get cluster labels</span>
        <span class="k">if</span> <span class="n">n_clusters</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;n_clusters is required for hierarchical clustering&quot;</span><span class="p">)</span>
        <span class="n">t0</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="n">cluster_labels</span> <span class="o">=</span> <span class="n">fcluster</span><span class="p">(</span><span class="n">linkage_matrix</span><span class="p">,</span> <span class="n">n_clusters</span><span class="p">,</span> <span class="n">criterion</span><span class="o">=</span><span class="s1">&#39;maxclust&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[CORE.CLUSTER] Hierarchical: fcluster took </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">t0</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2">s&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[CORE.CLUSTER] Hierarchical: Found </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">cluster_labels</span><span class="p">))</span><span class="si">}</span><span class="s2"> clusters&quot;</span><span class="p">)</span>
    
    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;leiden&#39;</span><span class="p">:</span>
        <span class="kn">import</span><span class="w"> </span><span class="nn">igraph</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">ig</span>
        <span class="kn">import</span><span class="w"> </span><span class="nn">leidenalg</span>
        
        <span class="c1"># Use k-NN graph (much faster than fully connected graph)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="kn">from</span><span class="w"> </span><span class="nn">sklearn.neighbors</span><span class="w"> </span><span class="kn">import</span> <span class="n">NearestNeighbors</span>
        <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ImportError</span><span class="p">(</span><span class="s2">&quot;scikit-learn is required for Leiden clustering (k-NN graph construction)&quot;</span><span class="p">)</span>
        
        <span class="n">n</span> <span class="o">=</span> <span class="n">data_values</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[CORE.CLUSTER] Leiden: Building k-NN graph with </span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s2"> nodes, k=</span><span class="si">{</span><span class="n">n_neighbors</span><span class="si">}</span><span class="s2">, metric=</span><span class="si">{</span><span class="n">metric</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
        <span class="n">t0</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="c1"># Build k-NN graph using sklearn (matching old GUI implementation)</span>
        <span class="n">nbrs</span> <span class="o">=</span> <span class="n">NearestNeighbors</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span><span class="n">n_neighbors</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="n">metric</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">data_values</span><span class="p">)</span>
        <span class="n">distances_knn</span><span class="p">,</span> <span class="n">indices_knn</span> <span class="o">=</span> <span class="n">nbrs</span><span class="o">.</span><span class="n">kneighbors</span><span class="p">(</span><span class="n">data_values</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[CORE.CLUSTER] Leiden: k-NN calculation took </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">t0</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2">s&quot;</span><span class="p">)</span>
        
        <span class="n">t0</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="c1"># Create graph from k-NN (matching old GUI implementation)</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="p">[]</span>
        
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j_idx</span><span class="p">,</span> <span class="n">neighbor_idx</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">indices_knn</span><span class="p">[</span><span class="n">i</span><span class="p">]):</span>
                <span class="k">if</span> <span class="n">neighbor_idx</span> <span class="o">!=</span> <span class="n">i</span><span class="p">:</span>  <span class="c1"># Don&#39;t add self-loops</span>
                    <span class="n">edges</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="n">neighbor_idx</span><span class="p">))</span>
                    <span class="c1"># Convert distance to similarity (inverse, normalized) - matching old GUI</span>
                    <span class="n">weight</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="n">distances_knn</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j_idx</span><span class="p">])</span>
                    <span class="n">weights</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">weight</span><span class="p">)</span>
        
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[CORE.CLUSTER] Leiden: Edge list creation took </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">t0</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2">s&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[CORE.CLUSTER] Leiden: Created </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span><span class="si">}</span><span class="s2"> edges from k-NN&quot;</span><span class="p">)</span>
        
        <span class="n">t0</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="c1"># Create symmetric graph (undirected - convert to symmetric)</span>
        <span class="n">edge_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">symmetric_edges</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">symmetric_weights</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">),</span> <span class="n">w</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">edges</span><span class="p">,</span> <span class="n">weights</span><span class="p">):</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">edge_set</span> <span class="ow">and</span> <span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">edge_set</span><span class="p">:</span>
                <span class="n">edge_set</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">))</span>
                <span class="n">symmetric_edges</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">))</span>
                <span class="n">symmetric_weights</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
        
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[CORE.CLUSTER] Leiden: Symmetric graph conversion took </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">t0</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2">s&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[CORE.CLUSTER] Leiden: Final graph has </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">symmetric_edges</span><span class="p">)</span><span class="si">}</span><span class="s2"> unique edges&quot;</span><span class="p">)</span>
        
        <span class="n">t0</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="c1"># Create igraph</span>
        <span class="n">g</span> <span class="o">=</span> <span class="n">ig</span><span class="o">.</span><span class="n">Graph</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="n">g</span><span class="o">.</span><span class="n">add_edges</span><span class="p">(</span><span class="n">symmetric_edges</span><span class="p">)</span>
        <span class="n">g</span><span class="o">.</span><span class="n">es</span><span class="p">[</span><span class="s1">&#39;weight&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">symmetric_weights</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[CORE.CLUSTER] Leiden: Graph creation took </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">t0</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2">s&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[CORE.CLUSTER] Leiden: Graph has </span><span class="si">{</span><span class="n">g</span><span class="o">.</span><span class="n">vcount</span><span class="p">()</span><span class="si">}</span><span class="s2"> vertices, </span><span class="si">{</span><span class="n">g</span><span class="o">.</span><span class="n">ecount</span><span class="p">()</span><span class="si">}</span><span class="s2"> edges&quot;</span><span class="p">)</span>
        
        <span class="n">t0</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="c1"># Run Leiden clustering (matching GUI)</span>
        <span class="n">partition</span> <span class="o">=</span> <span class="n">leidenalg</span><span class="o">.</span><span class="n">find_partition</span><span class="p">(</span>
            <span class="n">g</span><span class="p">,</span>
            <span class="n">leidenalg</span><span class="o">.</span><span class="n">RBConfigurationVertexPartition</span><span class="p">,</span>
            <span class="n">weights</span><span class="o">=</span><span class="s1">&#39;weight&#39;</span><span class="p">,</span>
            <span class="n">resolution_parameter</span><span class="o">=</span><span class="n">resolution</span><span class="p">,</span>
            <span class="n">seed</span><span class="o">=</span><span class="n">seed</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[CORE.CLUSTER] Leiden: find_partition took </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">t0</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2">s&quot;</span><span class="p">)</span>
        <span class="n">cluster_labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">partition</span><span class="o">.</span><span class="n">membership</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>  <span class="c1"># Start from 1 (matching GUI)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[CORE.CLUSTER] Leiden: Found </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">cluster_labels</span><span class="p">))</span><span class="si">}</span><span class="s2"> clusters&quot;</span><span class="p">)</span>
    
    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;louvain&#39;</span><span class="p">:</span>
        <span class="kn">import</span><span class="w"> </span><span class="nn">igraph</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">ig</span>
        <span class="kn">import</span><span class="w"> </span><span class="nn">leidenalg</span>
        
        <span class="c1"># Use k-NN graph (same as Leiden, but with modularity optimization)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="kn">from</span><span class="w"> </span><span class="nn">sklearn.neighbors</span><span class="w"> </span><span class="kn">import</span> <span class="n">NearestNeighbors</span>
        <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ImportError</span><span class="p">(</span><span class="s2">&quot;scikit-learn is required for Louvain clustering (k-NN graph construction)&quot;</span><span class="p">)</span>
        
        <span class="n">n</span> <span class="o">=</span> <span class="n">data_values</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[CORE.CLUSTER] Louvain: Building k-NN graph with </span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s2"> nodes, k=</span><span class="si">{</span><span class="n">n_neighbors</span><span class="si">}</span><span class="s2">, metric=</span><span class="si">{</span><span class="n">metric</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
        <span class="n">t0</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="c1"># Build k-NN graph using sklearn (same as Leiden)</span>
        <span class="n">nbrs</span> <span class="o">=</span> <span class="n">NearestNeighbors</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span><span class="n">n_neighbors</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="n">metric</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">data_values</span><span class="p">)</span>
        <span class="n">distances_knn</span><span class="p">,</span> <span class="n">indices_knn</span> <span class="o">=</span> <span class="n">nbrs</span><span class="o">.</span><span class="n">kneighbors</span><span class="p">(</span><span class="n">data_values</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[CORE.CLUSTER] Louvain: k-NN calculation took </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">t0</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2">s&quot;</span><span class="p">)</span>
        
        <span class="n">t0</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="c1"># Create graph from k-NN</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="p">[]</span>
        
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j_idx</span><span class="p">,</span> <span class="n">neighbor_idx</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">indices_knn</span><span class="p">[</span><span class="n">i</span><span class="p">]):</span>
                <span class="k">if</span> <span class="n">neighbor_idx</span> <span class="o">!=</span> <span class="n">i</span><span class="p">:</span>  <span class="c1"># Don&#39;t add self-loops</span>
                    <span class="n">edges</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="n">neighbor_idx</span><span class="p">))</span>
                    <span class="c1"># Convert distance to similarity (inverse, normalized)</span>
                    <span class="n">weight</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="n">distances_knn</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j_idx</span><span class="p">])</span>
                    <span class="n">weights</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">weight</span><span class="p">)</span>
        
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[CORE.CLUSTER] Louvain: Edge list creation took </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">t0</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2">s&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[CORE.CLUSTER] Louvain: Created </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span><span class="si">}</span><span class="s2"> edges from k-NN&quot;</span><span class="p">)</span>
        
        <span class="n">t0</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="c1"># Create symmetric graph (undirected - convert to symmetric)</span>
        <span class="n">edge_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">symmetric_edges</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">symmetric_weights</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">),</span> <span class="n">w</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">edges</span><span class="p">,</span> <span class="n">weights</span><span class="p">):</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">edge_set</span> <span class="ow">and</span> <span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">edge_set</span><span class="p">:</span>
                <span class="n">edge_set</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">))</span>
                <span class="n">symmetric_edges</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">))</span>
                <span class="n">symmetric_weights</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
        
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[CORE.CLUSTER] Louvain: Symmetric graph conversion took </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">t0</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2">s&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[CORE.CLUSTER] Louvain: Final graph has </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">symmetric_edges</span><span class="p">)</span><span class="si">}</span><span class="s2"> unique edges&quot;</span><span class="p">)</span>
        
        <span class="n">t0</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="c1"># Create igraph</span>
        <span class="n">g</span> <span class="o">=</span> <span class="n">ig</span><span class="o">.</span><span class="n">Graph</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="n">g</span><span class="o">.</span><span class="n">add_edges</span><span class="p">(</span><span class="n">symmetric_edges</span><span class="p">)</span>
        <span class="n">g</span><span class="o">.</span><span class="n">es</span><span class="p">[</span><span class="s1">&#39;weight&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">symmetric_weights</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[CORE.CLUSTER] Louvain: Graph creation took </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">t0</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2">s&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[CORE.CLUSTER] Louvain: Graph has </span><span class="si">{</span><span class="n">g</span><span class="o">.</span><span class="n">vcount</span><span class="p">()</span><span class="si">}</span><span class="s2"> vertices, </span><span class="si">{</span><span class="n">g</span><span class="o">.</span><span class="n">ecount</span><span class="p">()</span><span class="si">}</span><span class="s2"> edges&quot;</span><span class="p">)</span>
        
        <span class="n">t0</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="c1"># Run Louvain clustering (modularity optimization)</span>
        <span class="n">partition</span> <span class="o">=</span> <span class="n">leidenalg</span><span class="o">.</span><span class="n">find_partition</span><span class="p">(</span>
            <span class="n">g</span><span class="p">,</span>
            <span class="n">leidenalg</span><span class="o">.</span><span class="n">ModularityVertexPartition</span><span class="p">,</span>
            <span class="n">weights</span><span class="o">=</span><span class="s1">&#39;weight&#39;</span><span class="p">,</span>
            <span class="n">seed</span><span class="o">=</span><span class="n">seed</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[CORE.CLUSTER] Louvain: find_partition took </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">t0</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2">s&quot;</span><span class="p">)</span>
        <span class="n">cluster_labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">partition</span><span class="o">.</span><span class="n">membership</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>  <span class="c1"># Start from 1 (matching GUI)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[CORE.CLUSTER] Louvain: Found </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">cluster_labels</span><span class="p">))</span><span class="si">}</span><span class="s2"> clusters&quot;</span><span class="p">)</span>
    
    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;kmeans&#39;</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="kn">from</span><span class="w"> </span><span class="nn">sklearn.cluster</span><span class="w"> </span><span class="kn">import</span> <span class="n">KMeans</span>
        <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ImportError</span><span class="p">(</span><span class="s2">&quot;scikit-learn is required for K-means clustering&quot;</span><span class="p">)</span>
        
        <span class="n">n</span> <span class="o">=</span> <span class="n">data_values</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[CORE.CLUSTER] K-means: Starting with </span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s2"> cells, n_clusters=</span><span class="si">{</span><span class="n">n_clusters</span><span class="si">}</span><span class="s2">, n_init=</span><span class="si">{</span><span class="n">n_init</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">n_clusters</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;n_clusters is required for K-means clustering&quot;</span><span class="p">)</span>
        
        <span class="c1"># Set random seed for reproducibility</span>
        <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
        
        <span class="n">t0</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="c1"># Use efficient K-means implementation (n_init=10 is good balance)</span>
        <span class="n">kmeans</span> <span class="o">=</span> <span class="n">KMeans</span><span class="p">(</span><span class="n">n_clusters</span><span class="o">=</span><span class="n">n_clusters</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="n">seed</span><span class="p">,</span> <span class="n">n_init</span><span class="o">=</span><span class="n">n_init</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;lloyd&#39;</span><span class="p">)</span>
        <span class="n">cluster_labels</span> <span class="o">=</span> <span class="n">kmeans</span><span class="o">.</span><span class="n">fit_predict</span><span class="p">(</span><span class="n">data_values</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[CORE.CLUSTER] K-means: fit_predict took </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">t0</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2">s&quot;</span><span class="p">)</span>
        
        <span class="c1"># Convert to 1-based labels (matching GUI)</span>
        <span class="n">cluster_labels</span> <span class="o">=</span> <span class="n">cluster_labels</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[CORE.CLUSTER] K-means: Found </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">cluster_labels</span><span class="p">))</span><span class="si">}</span><span class="s2"> clusters&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[CORE.CLUSTER] K-means: Inertia: </span><span class="si">{</span><span class="n">kmeans</span><span class="o">.</span><span class="n">inertia_</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;hdbscan&#39;</span><span class="p">:</span>
        <span class="kn">import</span><span class="w"> </span><span class="nn">hdbscan</span>
        
        <span class="n">n</span> <span class="o">=</span> <span class="n">data_values</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[CORE.CLUSTER] HDBSCAN: Starting with </span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s2"> cells&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[CORE.CLUSTER] HDBSCAN: Parameters: min_cluster_size=</span><span class="si">{</span><span class="n">min_cluster_size</span><span class="si">}</span><span class="s2">, min_samples=</span><span class="si">{</span><span class="n">min_samples</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[CORE.CLUSTER] HDBSCAN: cluster_selection_method=</span><span class="si">{</span><span class="n">cluster_selection_method</span><span class="si">}</span><span class="s2">, metric=</span><span class="si">{</span><span class="n">hdbscan_metric</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        
        <span class="c1"># Set random seed for reproducibility</span>
        <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
        
        <span class="n">t0</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="c1"># Create HDBSCAN clusterer (efficient implementation)</span>
        <span class="n">clusterer</span> <span class="o">=</span> <span class="n">hdbscan</span><span class="o">.</span><span class="n">HDBSCAN</span><span class="p">(</span>
            <span class="n">min_cluster_size</span><span class="o">=</span><span class="n">min_cluster_size</span><span class="p">,</span>
            <span class="n">min_samples</span><span class="o">=</span><span class="n">min_samples</span><span class="p">,</span>
            <span class="n">cluster_selection_method</span><span class="o">=</span><span class="n">cluster_selection_method</span><span class="p">,</span>
            <span class="n">metric</span><span class="o">=</span><span class="n">hdbscan_metric</span><span class="p">,</span>
            <span class="n">core_dist_n_jobs</span><span class="o">=</span><span class="mi">1</span>  <span class="c1"># Use single thread for stability</span>
        <span class="p">)</span>
        <span class="n">cluster_labels</span> <span class="o">=</span> <span class="n">clusterer</span><span class="o">.</span><span class="n">fit_predict</span><span class="p">(</span><span class="n">data_values</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[CORE.CLUSTER] HDBSCAN: fit_predict took </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">t0</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2">s&quot;</span><span class="p">)</span>
        
        <span class="c1"># HDBSCAN uses -1 for noise, convert to 1-based (matching GUI)</span>
        <span class="n">n_noise</span> <span class="o">=</span> <span class="p">(</span><span class="n">cluster_labels</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="n">cluster_labels</span> <span class="o">=</span> <span class="n">cluster_labels</span> <span class="o">+</span> <span class="mi">1</span>  <span class="c1"># -1 becomes 0, others become 1-based</span>
        <span class="n">n_clusters_found</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">cluster_labels</span><span class="p">[</span><span class="n">cluster_labels</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]))</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[CORE.CLUSTER] HDBSCAN: Found </span><span class="si">{</span><span class="n">n_clusters_found</span><span class="si">}</span><span class="s2"> clusters, </span><span class="si">{</span><span class="n">n_noise</span><span class="si">}</span><span class="s2"> noise points&quot;</span><span class="p">)</span>
    
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unknown clustering method: </span><span class="si">{</span><span class="n">method</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[CORE.CLUSTER] Clustering algorithm took </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">t_cluster_start</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2">s total&quot;</span><span class="p">)</span>
    
    <span class="c1"># Map cluster labels back to original dataframe indices</span>
    <span class="n">t0</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="c1"># Create a series with cluster labels for the cleaned data</span>
    <span class="n">cluster_series</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">cluster_labels</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">original_indices</span><span class="p">)</span>
    
    <span class="c1"># Add cluster labels to original dataframe (NaN for rows that were dropped)</span>
    <span class="n">result_df</span> <span class="o">=</span> <span class="n">features_df</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">result_df</span><span class="p">[</span><span class="s1">&#39;cluster&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">cluster_series</span>
    <span class="c1"># Fill NaN with 0 (noise/unassigned) if needed</span>
    <span class="n">result_df</span><span class="p">[</span><span class="s1">&#39;cluster&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">result_df</span><span class="p">[</span><span class="s1">&#39;cluster&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[CORE.CLUSTER] Mapping labels back took </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">t0</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2">s&quot;</span><span class="p">)</span>
    
    <span class="c1"># Save output if path is provided</span>
    <span class="k">if</span> <span class="n">output_path</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">t0</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="n">output_path</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">output_path</span><span class="p">)</span>
        <span class="n">result_df</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">output_path</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[CORE.CLUSTER] Saving output took </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">t0</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2">s&quot;</span><span class="p">)</span>
    
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;[CORE.CLUSTER] Total clustering time: </span><span class="si">{</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">t_start</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2">s&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">result_df</span></div>



<div class="viewcode-block" id="build_spatial_graph">
<a class="viewcode-back" href="../../api_core.html#openimc.core.build_spatial_graph">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">build_spatial_graph</span><span class="p">(</span>
    <span class="n">features_df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
    <span class="n">method</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;kNN&quot;</span><span class="p">,</span>
    <span class="n">k_neighbors</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">6</span><span class="p">,</span>
    <span class="n">radius</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">pixel_size_um</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
    <span class="n">roi_column</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">detect_communities</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">community_seed</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">42</span><span class="p">,</span>
    <span class="n">output_path</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Path</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">Optional</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Build spatial graph from cell centroids.</span>
<span class="sd">    </span>
<span class="sd">    This function creates a spatial graph connecting cells based on their</span>
<span class="sd">    spatial proximity. It supports kNN, radius-based, and Delaunay triangulation</span>
<span class="sd">    methods. The graph can be built per-ROI (if roi_column is provided) or globally.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        features_df: DataFrame with cell features, must contain &#39;centroid_x&#39; and &#39;centroid_y&#39;</span>
<span class="sd">        method: Graph construction method (&#39;kNN&#39;, &#39;Radius&#39;, or &#39;Delaunay&#39;)</span>
<span class="sd">        k_neighbors: Number of neighbors for kNN method</span>
<span class="sd">        radius: Radius in pixels for radius-based method (required if method=&#39;Radius&#39;)</span>
<span class="sd">        pixel_size_um: Pixel size in micrometers for distance conversion</span>
<span class="sd">        roi_column: Column name for ROI grouping (e.g., &#39;acquisition_id&#39;). If None, builds global graph</span>
<span class="sd">        detect_communities: Whether to detect communities using Leiden algorithm</span>
<span class="sd">        community_seed: Random seed for community detection</span>
<span class="sd">        output_path: Optional path to save edges CSV file</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        Tuple of (edges_df, features_with_communities_df)</span>
<span class="sd">        - edges_df: DataFrame with columns [&#39;roi_id&#39;, &#39;cell_id_A&#39;, &#39;cell_id_B&#39;, &#39;distance_um&#39;] (or [&#39;source&#39;, &#39;target&#39;, &#39;distance&#39;, &#39;distance_um&#39;] for global)</span>
<span class="sd">        - features_with_communities_df: DataFrame with &#39;spatial_community&#39; column if detect_communities=True, else None</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Validate required columns</span>
    <span class="n">required_cols</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;centroid_x&#39;</span><span class="p">,</span> <span class="s1">&#39;centroid_y&#39;</span><span class="p">]</span>
    <span class="n">missing</span> <span class="o">=</span> <span class="p">[</span><span class="n">col</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">required_cols</span> <span class="k">if</span> <span class="n">col</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">features_df</span><span class="o">.</span><span class="n">columns</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">missing</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Required columns for spatial analysis: </span><span class="si">{</span><span class="n">missing</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    
    <span class="c1"># Validate method</span>
    <span class="k">if</span> <span class="n">method</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;kNN&#39;</span><span class="p">,</span> <span class="s1">&#39;Radius&#39;</span><span class="p">,</span> <span class="s1">&#39;Delaunay&#39;</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unknown graph method: </span><span class="si">{</span><span class="n">method</span><span class="si">}</span><span class="s2">. Must be &#39;kNN&#39;, &#39;Radius&#39;, or &#39;Delaunay&#39;&quot;</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;Radius&#39;</span> <span class="ow">and</span> <span class="n">radius</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;radius parameter is required for &#39;Radius&#39; method&quot;</span><span class="p">)</span>
    
    <span class="c1"># Determine ROI column</span>
    <span class="k">if</span> <span class="n">roi_column</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Try to auto-detect ROI column</span>
        <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;acquisition_id&#39;</span><span class="p">,</span> <span class="s1">&#39;roi_id&#39;</span><span class="p">,</span> <span class="s1">&#39;roi&#39;</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">features_df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                <span class="n">roi_column</span> <span class="o">=</span> <span class="n">col</span>
                <span class="k">break</span>
    
    <span class="c1"># Build graph per ROI if roi_column exists, otherwise build globally</span>
    <span class="k">if</span> <span class="n">roi_column</span> <span class="ow">and</span> <span class="n">roi_column</span> <span class="ow">in</span> <span class="n">features_df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_build_spatial_graph_per_roi</span><span class="p">(</span>
            <span class="n">features_df</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">k_neighbors</span><span class="p">,</span> <span class="n">radius</span><span class="p">,</span> <span class="n">pixel_size_um</span><span class="p">,</span>
            <span class="n">roi_column</span><span class="p">,</span> <span class="n">detect_communities</span><span class="p">,</span> <span class="n">community_seed</span><span class="p">,</span> <span class="n">output_path</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_build_spatial_graph_global</span><span class="p">(</span>
            <span class="n">features_df</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">k_neighbors</span><span class="p">,</span> <span class="n">radius</span><span class="p">,</span> <span class="n">pixel_size_um</span><span class="p">,</span>
            <span class="n">detect_communities</span><span class="p">,</span> <span class="n">community_seed</span><span class="p">,</span> <span class="n">output_path</span>
        <span class="p">)</span></div>



<span class="k">def</span><span class="w"> </span><span class="nf">_build_spatial_graph_per_roi</span><span class="p">(</span>
    <span class="n">features_df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
    <span class="n">method</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">k_neighbors</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">radius</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
    <span class="n">pixel_size_um</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">roi_column</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">detect_communities</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
    <span class="n">community_seed</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">output_path</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Path</span><span class="p">]]</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">Optional</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Build spatial graph per ROI.&quot;&quot;&quot;</span>
    <span class="n">edge_records</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="k">for</span> <span class="n">roi_id</span><span class="p">,</span> <span class="n">roi_df</span> <span class="ow">in</span> <span class="n">features_df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">roi_column</span><span class="p">):</span>
        <span class="n">roi_df</span> <span class="o">=</span> <span class="n">roi_df</span><span class="o">.</span><span class="n">dropna</span><span class="p">(</span><span class="n">subset</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;centroid_x&quot;</span><span class="p">,</span> <span class="s2">&quot;centroid_y&quot;</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">roi_df</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
            <span class="k">continue</span>
        
        <span class="n">coords_px</span> <span class="o">=</span> <span class="n">roi_df</span><span class="p">[[</span><span class="s2">&quot;centroid_x&quot;</span><span class="p">,</span> <span class="s2">&quot;centroid_y&quot;</span><span class="p">]]</span><span class="o">.</span><span class="n">values</span>
        <span class="n">cell_ids</span> <span class="o">=</span> <span class="n">roi_df</span><span class="p">[</span><span class="s2">&quot;cell_id&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="k">if</span> <span class="s1">&#39;cell_id&#39;</span> <span class="ow">in</span> <span class="n">roi_df</span><span class="o">.</span><span class="n">columns</span> <span class="k">else</span> <span class="n">roi_df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">values</span>
        
        <span class="c1"># Build spatial tree</span>
        <span class="n">tree</span> <span class="o">=</span> <span class="n">cKDTree</span><span class="p">(</span><span class="n">coords_px</span><span class="p">)</span>
        
        <span class="c1"># Use set to deduplicate edges</span>
        <span class="n">roi_edges_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        
        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;kNN&quot;</span><span class="p">:</span>
            <span class="c1"># Query k+1 (including self), exclude self idx 0</span>
            <span class="n">query_k</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">k_neighbors</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">coords_px</span><span class="p">)))</span>
            <span class="n">dists</span><span class="p">,</span> <span class="n">idxs</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">coords_px</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">query_k</span><span class="p">)</span>
            
            <span class="c1"># Handle scalar case</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">dists</span><span class="p">):</span>
                <span class="n">dists</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">dists</span><span class="p">]])</span>
                <span class="n">idxs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">idxs</span><span class="p">]])</span>
            <span class="k">elif</span> <span class="n">dists</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">dists</span> <span class="o">=</span> <span class="n">dists</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span>
                <span class="n">idxs</span> <span class="o">=</span> <span class="n">idxs</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span>
            
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">coords_px</span><span class="p">)):</span>
                <span class="n">src_cell_id</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">cell_ids</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">dists</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">k_neighbors</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)):</span>
                    <span class="n">nbr_idx</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">idxs</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">])</span>
                    <span class="k">if</span> <span class="n">nbr_idx</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">nbr_idx</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">coords_px</span><span class="p">):</span>
                        <span class="k">continue</span>
                    <span class="n">dst_cell_id</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">cell_ids</span><span class="p">[</span><span class="n">nbr_idx</span><span class="p">])</span>
                    <span class="n">dist_px</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">dists</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">])</span>
                    <span class="n">dist_um</span> <span class="o">=</span> <span class="n">dist_px</span> <span class="o">*</span> <span class="n">pixel_size_um</span>
                    
                    <span class="c1"># Create canonical edge (smaller cell_id first)</span>
                    <span class="n">edge_key</span> <span class="o">=</span> <span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">src_cell_id</span><span class="p">,</span> <span class="n">dst_cell_id</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">src_cell_id</span><span class="p">,</span> <span class="n">dst_cell_id</span><span class="p">))</span>
                    <span class="k">if</span> <span class="n">edge_key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">roi_edges_set</span><span class="p">:</span>
                        <span class="n">roi_edges_set</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">edge_key</span><span class="p">)</span>
                        <span class="n">edge_records</span><span class="o">.</span><span class="n">append</span><span class="p">({</span>
                            <span class="s1">&#39;roi_id&#39;</span><span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="n">roi_id</span><span class="p">),</span>
                            <span class="s1">&#39;cell_id_A&#39;</span><span class="p">:</span> <span class="n">src_cell_id</span><span class="p">,</span>
                            <span class="s1">&#39;cell_id_B&#39;</span><span class="p">:</span> <span class="n">dst_cell_id</span><span class="p">,</span>
                            <span class="s1">&#39;distance_um&#39;</span><span class="p">:</span> <span class="n">dist_um</span>
                        <span class="p">})</span>
        
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;Radius&quot;</span><span class="p">:</span>
            <span class="c1"># Radius graph: radius is in pixels</span>
            <span class="n">radius_px</span> <span class="o">=</span> <span class="n">radius</span>
            <span class="n">pairs</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">query_pairs</span><span class="p">(</span><span class="n">r</span><span class="o">=</span><span class="n">radius_px</span><span class="p">)</span>
            
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">pairs</span><span class="p">:</span>
                <span class="n">a_id</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">cell_ids</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">i</span><span class="p">)])</span>
                <span class="n">b_id</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">cell_ids</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">j</span><span class="p">)])</span>
                
                <span class="c1"># Create canonical edge (smaller cell_id first)</span>
                <span class="n">edge_key</span> <span class="o">=</span> <span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">a_id</span><span class="p">,</span> <span class="n">b_id</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">a_id</span><span class="p">,</span> <span class="n">b_id</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">edge_key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">roi_edges_set</span><span class="p">:</span>
                    <span class="n">roi_edges_set</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">edge_key</span><span class="p">)</span>
                    <span class="n">dist_um</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">coords_px</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">i</span><span class="p">)]</span> <span class="o">-</span> <span class="n">coords_px</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">j</span><span class="p">)]))</span> <span class="o">*</span> <span class="n">pixel_size_um</span>
                    <span class="n">edge_records</span><span class="o">.</span><span class="n">append</span><span class="p">({</span>
                        <span class="s1">&#39;roi_id&#39;</span><span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="n">roi_id</span><span class="p">),</span>
                        <span class="s1">&#39;cell_id_A&#39;</span><span class="p">:</span> <span class="n">a_id</span><span class="p">,</span>
                        <span class="s1">&#39;cell_id_B&#39;</span><span class="p">:</span> <span class="n">b_id</span><span class="p">,</span>
                        <span class="s1">&#39;distance_um&#39;</span><span class="p">:</span> <span class="n">dist_um</span>
                    <span class="p">})</span>
        
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;Delaunay&quot;</span><span class="p">:</span>
            <span class="c1"># Delaunay triangulation</span>
            <span class="n">tri</span> <span class="o">=</span> <span class="n">Delaunay</span><span class="p">(</span><span class="n">coords_px</span><span class="p">)</span>
            <span class="n">edges_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
            
            <span class="k">for</span> <span class="n">simplex</span> <span class="ow">in</span> <span class="n">tri</span><span class="o">.</span><span class="n">simplices</span><span class="p">:</span>
                <span class="c1"># Each simplex has 3 vertices, create edges between all pairs</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">):</span>
                        <span class="n">v1</span><span class="p">,</span> <span class="n">v2</span> <span class="o">=</span> <span class="n">simplex</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">simplex</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                        <span class="c1"># Create canonical edge (smaller index first)</span>
                        <span class="n">edge_key</span> <span class="o">=</span> <span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">))</span>
                        <span class="k">if</span> <span class="n">edge_key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">edges_set</span><span class="p">:</span>
                            <span class="n">edges_set</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">edge_key</span><span class="p">)</span>
                            <span class="n">a_id</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">cell_ids</span><span class="p">[</span><span class="n">v1</span><span class="p">])</span>
                            <span class="n">b_id</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">cell_ids</span><span class="p">[</span><span class="n">v2</span><span class="p">])</span>
                            <span class="n">dist_um</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">coords_px</span><span class="p">[</span><span class="n">v1</span><span class="p">]</span> <span class="o">-</span> <span class="n">coords_px</span><span class="p">[</span><span class="n">v2</span><span class="p">]))</span> <span class="o">*</span> <span class="n">pixel_size_um</span>
                            <span class="n">edge_records</span><span class="o">.</span><span class="n">append</span><span class="p">({</span>
                                <span class="s1">&#39;roi_id&#39;</span><span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="n">roi_id</span><span class="p">),</span>
                                <span class="s1">&#39;cell_id_A&#39;</span><span class="p">:</span> <span class="n">a_id</span><span class="p">,</span>
                                <span class="s1">&#39;cell_id_B&#39;</span><span class="p">:</span> <span class="n">b_id</span><span class="p">,</span>
                                <span class="s1">&#39;distance_um&#39;</span><span class="p">:</span> <span class="n">dist_um</span>
                            <span class="p">})</span>
    
    <span class="c1"># Create edges dataframe</span>
    <span class="n">edges_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">edge_records</span><span class="p">)</span>
    
    <span class="c1"># Detect communities if requested</span>
    <span class="n">features_with_communities</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">detect_communities</span><span class="p">:</span>
        <span class="n">features_with_communities</span> <span class="o">=</span> <span class="n">_detect_spatial_communities</span><span class="p">(</span>
            <span class="n">features_df</span><span class="p">,</span> <span class="n">edges_df</span><span class="p">,</span> <span class="n">roi_column</span><span class="p">,</span> <span class="n">pixel_size_um</span><span class="p">,</span> <span class="n">community_seed</span>
        <span class="p">)</span>
    
    <span class="c1"># Save output if path is provided</span>
    <span class="k">if</span> <span class="n">output_path</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">output_path</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">output_path</span><span class="p">)</span>
        <span class="n">edges_df</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">output_path</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">features_with_communities</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">community_output</span> <span class="o">=</span> <span class="n">output_path</span><span class="o">.</span><span class="n">parent</span> <span class="o">/</span> <span class="p">(</span><span class="n">output_path</span><span class="o">.</span><span class="n">stem</span> <span class="o">+</span> <span class="s1">&#39;_with_communities.csv&#39;</span><span class="p">)</span>
            <span class="n">features_with_communities</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">community_output</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">edges_df</span><span class="p">,</span> <span class="n">features_with_communities</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_build_spatial_graph_global</span><span class="p">(</span>
    <span class="n">features_df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
    <span class="n">method</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">k_neighbors</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">radius</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
    <span class="n">pixel_size_um</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">detect_communities</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
    <span class="n">community_seed</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">output_path</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Path</span><span class="p">]]</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">Optional</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Build spatial graph globally (single ROI).&quot;&quot;&quot;</span>
    <span class="n">coords</span> <span class="o">=</span> <span class="n">features_df</span><span class="p">[[</span><span class="s1">&#39;centroid_x&#39;</span><span class="p">,</span> <span class="s1">&#39;centroid_y&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">dropna</span><span class="p">()</span><span class="o">.</span><span class="n">values</span>
    
    <span class="c1"># Build spatial tree</span>
    <span class="n">tree</span> <span class="o">=</span> <span class="n">cKDTree</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span>
    
    <span class="c1"># Build edges</span>
    <span class="n">edge_records</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">edge_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    
    <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;kNN&quot;</span><span class="p">:</span>
        <span class="n">query_k</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">k_neighbors</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">coords</span><span class="p">)))</span>
        <span class="n">dists</span><span class="p">,</span> <span class="n">idxs</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">query_k</span><span class="p">)</span>
        
        <span class="c1"># Handle scalar case</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">dists</span><span class="p">):</span>
            <span class="n">dists</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">dists</span><span class="p">]])</span>
            <span class="n">idxs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">idxs</span><span class="p">]])</span>
        <span class="k">elif</span> <span class="n">dists</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">dists</span> <span class="o">=</span> <span class="n">dists</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span>
            <span class="n">idxs</span> <span class="o">=</span> <span class="n">idxs</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span>
        
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">coords</span><span class="p">)):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">dists</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">k_neighbors</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)):</span>
                <span class="n">nbr_idx</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">idxs</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">nbr_idx</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">nbr_idx</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">coords</span><span class="p">):</span>
                    <span class="k">continue</span>
                <span class="n">dist_px</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">dists</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">])</span>
                <span class="n">dist_um</span> <span class="o">=</span> <span class="n">dist_px</span> <span class="o">*</span> <span class="n">pixel_size_um</span>
                
                <span class="n">edge_key</span> <span class="o">=</span> <span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">nbr_idx</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">nbr_idx</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">edge_key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">edge_set</span><span class="p">:</span>
                    <span class="n">edge_set</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">edge_key</span><span class="p">)</span>
                    <span class="n">edge_records</span><span class="o">.</span><span class="n">append</span><span class="p">({</span>
                        <span class="s1">&#39;source&#39;</span><span class="p">:</span> <span class="n">i</span><span class="p">,</span>
                        <span class="s1">&#39;target&#39;</span><span class="p">:</span> <span class="n">nbr_idx</span><span class="p">,</span>
                        <span class="s1">&#39;distance&#39;</span><span class="p">:</span> <span class="n">dist_px</span><span class="p">,</span>  <span class="c1"># Keep in pixels for compatibility</span>
                        <span class="s1">&#39;distance_um&#39;</span><span class="p">:</span> <span class="n">dist_um</span>
                    <span class="p">})</span>
    
    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;Radius&quot;</span><span class="p">:</span>
        <span class="n">radius_px</span> <span class="o">=</span> <span class="n">radius</span>
        <span class="n">pairs</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">query_pairs</span><span class="p">(</span><span class="n">r</span><span class="o">=</span><span class="n">radius_px</span><span class="p">)</span>
        
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">pairs</span><span class="p">:</span>
            <span class="n">edge_key</span> <span class="o">=</span> <span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">edge_key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">edge_set</span><span class="p">:</span>
                <span class="n">edge_set</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">edge_key</span><span class="p">)</span>
                <span class="n">dist_px</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">coords</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">coords</span><span class="p">[</span><span class="n">j</span><span class="p">]))</span>
                <span class="n">dist_um</span> <span class="o">=</span> <span class="n">dist_px</span> <span class="o">*</span> <span class="n">pixel_size_um</span>
                <span class="n">edge_records</span><span class="o">.</span><span class="n">append</span><span class="p">({</span>
                    <span class="s1">&#39;source&#39;</span><span class="p">:</span> <span class="n">i</span><span class="p">,</span>
                    <span class="s1">&#39;target&#39;</span><span class="p">:</span> <span class="n">j</span><span class="p">,</span>
                    <span class="s1">&#39;distance&#39;</span><span class="p">:</span> <span class="n">dist_px</span><span class="p">,</span>
                    <span class="s1">&#39;distance_um&#39;</span><span class="p">:</span> <span class="n">dist_um</span>
                <span class="p">})</span>
    
    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;Delaunay&quot;</span><span class="p">:</span>
        <span class="n">tri</span> <span class="o">=</span> <span class="n">Delaunay</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span>
        <span class="n">edges_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        
        <span class="k">for</span> <span class="n">simplex</span> <span class="ow">in</span> <span class="n">tri</span><span class="o">.</span><span class="n">simplices</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">):</span>
                    <span class="n">v1</span><span class="p">,</span> <span class="n">v2</span> <span class="o">=</span> <span class="n">simplex</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">simplex</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                    <span class="n">edge_key</span> <span class="o">=</span> <span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">))</span>
                    <span class="k">if</span> <span class="n">edge_key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">edges_set</span><span class="p">:</span>
                        <span class="n">edges_set</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">edge_key</span><span class="p">)</span>
                        <span class="n">dist_px</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">coords</span><span class="p">[</span><span class="n">v1</span><span class="p">]</span> <span class="o">-</span> <span class="n">coords</span><span class="p">[</span><span class="n">v2</span><span class="p">]))</span>
                        <span class="n">dist_um</span> <span class="o">=</span> <span class="n">dist_px</span> <span class="o">*</span> <span class="n">pixel_size_um</span>
                        <span class="n">edge_records</span><span class="o">.</span><span class="n">append</span><span class="p">({</span>
                            <span class="s1">&#39;source&#39;</span><span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="n">v1</span><span class="p">),</span>
                            <span class="s1">&#39;target&#39;</span><span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="n">v2</span><span class="p">),</span>
                            <span class="s1">&#39;distance&#39;</span><span class="p">:</span> <span class="n">dist_px</span><span class="p">,</span>
                            <span class="s1">&#39;distance_um&#39;</span><span class="p">:</span> <span class="n">dist_um</span>
                        <span class="p">})</span>
    
    <span class="c1"># Create edges dataframe</span>
    <span class="n">edges_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">edge_records</span><span class="p">)</span>
    
    <span class="c1"># Detect communities if requested</span>
    <span class="n">features_with_communities</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">detect_communities</span><span class="p">:</span>
        <span class="n">features_with_communities</span> <span class="o">=</span> <span class="n">_detect_spatial_communities_global</span><span class="p">(</span>
            <span class="n">features_df</span><span class="p">,</span> <span class="n">edges_df</span><span class="p">,</span> <span class="n">pixel_size_um</span><span class="p">,</span> <span class="n">community_seed</span>
        <span class="p">)</span>
    
    <span class="c1"># Save output if path is provided</span>
    <span class="k">if</span> <span class="n">output_path</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">output_path</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">output_path</span><span class="p">)</span>
        <span class="n">edges_df</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">output_path</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">features_with_communities</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">community_output</span> <span class="o">=</span> <span class="n">output_path</span><span class="o">.</span><span class="n">parent</span> <span class="o">/</span> <span class="p">(</span><span class="n">output_path</span><span class="o">.</span><span class="n">stem</span> <span class="o">+</span> <span class="s1">&#39;_with_communities.csv&#39;</span><span class="p">)</span>
            <span class="n">features_with_communities</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">community_output</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">edges_df</span><span class="p">,</span> <span class="n">features_with_communities</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_detect_spatial_communities</span><span class="p">(</span>
    <span class="n">features_df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
    <span class="n">edges_df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
    <span class="n">roi_column</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">pixel_size_um</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">seed</span><span class="p">:</span> <span class="nb">int</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Detect communities using Leiden algorithm for per-ROI graphs.&quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="kn">import</span><span class="w"> </span><span class="nn">igraph</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">ig</span>
        <span class="kn">import</span><span class="w"> </span><span class="nn">leidenalg</span>
    <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ImportError</span><span class="p">(</span><span class="s2">&quot;igraph and leidenalg are required for community detection&quot;</span><span class="p">)</span>
    
    <span class="c1"># Build graph from edges</span>
    <span class="c1"># Map cell IDs to indices if needed</span>
    <span class="k">if</span> <span class="s1">&#39;cell_id_A&#39;</span> <span class="ow">in</span> <span class="n">edges_df</span><span class="o">.</span><span class="n">columns</span> <span class="ow">and</span> <span class="s1">&#39;cell_id&#39;</span> <span class="ow">in</span> <span class="n">features_df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
        <span class="c1"># Create mapping from cell_id to index</span>
        <span class="n">cell_id_to_idx</span> <span class="o">=</span> <span class="p">{</span><span class="n">cell_id</span><span class="p">:</span> <span class="n">idx</span> <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">cell_id</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">features_df</span><span class="p">[</span><span class="s1">&#39;cell_id&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">)}</span>
        <span class="n">edge_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">edges_df</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
            <span class="n">cell_a</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="s1">&#39;cell_id_A&#39;</span><span class="p">])</span>
            <span class="n">cell_b</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">e</span><span class="p">[</span><span class="s1">&#39;cell_id_B&#39;</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">cell_a</span> <span class="ow">in</span> <span class="n">cell_id_to_idx</span> <span class="ow">and</span> <span class="n">cell_b</span> <span class="ow">in</span> <span class="n">cell_id_to_idx</span><span class="p">:</span>
                <span class="n">edge_list</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">cell_id_to_idx</span><span class="p">[</span><span class="n">cell_a</span><span class="p">],</span> <span class="n">cell_id_to_idx</span><span class="p">[</span><span class="n">cell_b</span><span class="p">]))</span>
                <span class="n">dist_um</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;distance_um&#39;</span><span class="p">,</span> <span class="n">e</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;distance&#39;</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">*</span> <span class="n">pixel_size_um</span><span class="p">)</span>
                <span class="n">weights</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="n">dist_um</span> <span class="o">+</span> <span class="mf">1e-6</span><span class="p">))</span>
        <span class="n">g</span> <span class="o">=</span> <span class="n">ig</span><span class="o">.</span><span class="n">Graph</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">features_df</span><span class="p">))</span>
        <span class="n">g</span><span class="o">.</span><span class="n">add_edges</span><span class="p">(</span><span class="n">edge_list</span><span class="p">)</span>
        <span class="n">g</span><span class="o">.</span><span class="n">es</span><span class="p">[</span><span class="s1">&#39;weight&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">weights</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Use index-based edges</span>
        <span class="n">g</span> <span class="o">=</span> <span class="n">ig</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
        <span class="n">g</span><span class="o">.</span><span class="n">add_vertices</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">features_df</span><span class="p">))</span>
        <span class="n">edge_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">edges_df</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
            <span class="n">source</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;source&#39;</span><span class="p">,</span> <span class="n">e</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;cell_id_A&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)))</span>
            <span class="n">target</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;target&#39;</span><span class="p">,</span> <span class="n">e</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;cell_id_B&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)))</span>
            <span class="n">edge_list</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">source</span><span class="p">,</span> <span class="n">target</span><span class="p">))</span>
            <span class="n">dist_um</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;distance_um&#39;</span><span class="p">,</span> <span class="n">e</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;distance&#39;</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">*</span> <span class="n">pixel_size_um</span><span class="p">)</span>
            <span class="n">weights</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="n">dist_um</span> <span class="o">+</span> <span class="mf">1e-6</span><span class="p">))</span>
        <span class="n">g</span><span class="o">.</span><span class="n">add_edges</span><span class="p">(</span><span class="n">edge_list</span><span class="p">)</span>
        <span class="n">g</span><span class="o">.</span><span class="n">es</span><span class="p">[</span><span class="s1">&#39;weight&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">weights</span>
    
    <span class="c1"># Run community detection with seed</span>
    <span class="n">partition</span> <span class="o">=</span> <span class="n">leidenalg</span><span class="o">.</span><span class="n">find_partition</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">leidenalg</span><span class="o">.</span><span class="n">ModularityVertexPartition</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="n">seed</span><span class="p">)</span>
    <span class="n">communities</span> <span class="o">=</span> <span class="n">partition</span><span class="o">.</span><span class="n">membership</span>
    
    <span class="c1"># Map community labels back to dataframe</span>
    <span class="n">result_df</span> <span class="o">=</span> <span class="n">features_df</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">if</span> <span class="s1">&#39;cell_id_A&#39;</span> <span class="ow">in</span> <span class="n">edges_df</span><span class="o">.</span><span class="n">columns</span> <span class="ow">and</span> <span class="s1">&#39;cell_id&#39;</span> <span class="ow">in</span> <span class="n">features_df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
        <span class="c1"># Map from graph vertex index to cell_id, then to dataframe index</span>
        <span class="n">idx_to_cell_id</span> <span class="o">=</span> <span class="p">{</span><span class="n">idx</span><span class="p">:</span> <span class="n">cell_id</span> <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">cell_id</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">features_df</span><span class="p">[</span><span class="s1">&#39;cell_id&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">)}</span>
        <span class="n">community_series</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="n">features_df</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">vertex_idx</span><span class="p">,</span> <span class="n">community</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">communities</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">vertex_idx</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">features_df</span><span class="p">):</span>
                <span class="n">community_series</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">vertex_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">community</span>
        <span class="n">result_df</span><span class="p">[</span><span class="s1">&#39;spatial_community&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">community_series</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Direct mapping (vertex index = dataframe index)</span>
        <span class="n">result_df</span><span class="p">[</span><span class="s1">&#39;spatial_community&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">communities</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">features_df</span><span class="p">)]</span>
    
    <span class="k">return</span> <span class="n">result_df</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_detect_spatial_communities_global</span><span class="p">(</span>
    <span class="n">features_df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
    <span class="n">edges_df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
    <span class="n">pixel_size_um</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">seed</span><span class="p">:</span> <span class="nb">int</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Detect communities using Leiden algorithm for global graphs.&quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="kn">import</span><span class="w"> </span><span class="nn">igraph</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">ig</span>
        <span class="kn">import</span><span class="w"> </span><span class="nn">leidenalg</span>
    <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ImportError</span><span class="p">(</span><span class="s2">&quot;igraph and leidenalg are required for community detection&quot;</span><span class="p">)</span>
    
    <span class="c1"># Build graph from edges</span>
    <span class="n">g</span> <span class="o">=</span> <span class="n">ig</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
    <span class="n">g</span><span class="o">.</span><span class="n">add_vertices</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">features_df</span><span class="p">))</span>
    <span class="n">edge_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">weights</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">edges_df</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
        <span class="n">source</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;source&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
        <span class="n">target</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;target&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
        <span class="n">edge_list</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">source</span><span class="p">,</span> <span class="n">target</span><span class="p">))</span>
        <span class="n">dist_um</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;distance_um&#39;</span><span class="p">,</span> <span class="n">e</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;distance&#39;</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">*</span> <span class="n">pixel_size_um</span><span class="p">)</span>
        <span class="n">weights</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="n">dist_um</span> <span class="o">+</span> <span class="mf">1e-6</span><span class="p">))</span>
    <span class="n">g</span><span class="o">.</span><span class="n">add_edges</span><span class="p">(</span><span class="n">edge_list</span><span class="p">)</span>
    <span class="n">g</span><span class="o">.</span><span class="n">es</span><span class="p">[</span><span class="s1">&#39;weight&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">weights</span>
    
    <span class="c1"># Run community detection with seed</span>
    <span class="n">partition</span> <span class="o">=</span> <span class="n">leidenalg</span><span class="o">.</span><span class="n">find_partition</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">leidenalg</span><span class="o">.</span><span class="n">ModularityVertexPartition</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="n">seed</span><span class="p">)</span>
    <span class="n">communities</span> <span class="o">=</span> <span class="n">partition</span><span class="o">.</span><span class="n">membership</span>
    
    <span class="c1"># Map community labels back to dataframe</span>
    <span class="n">result_df</span> <span class="o">=</span> <span class="n">features_df</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">result_df</span><span class="p">[</span><span class="s1">&#39;spatial_community&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">communities</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">features_df</span><span class="p">)]</span>
    
    <span class="k">return</span> <span class="n">result_df</span>


<div class="viewcode-block" id="batch_correction">
<a class="viewcode-back" href="../../api_core.html#openimc.core.batch_correction">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">batch_correction</span><span class="p">(</span>
    <span class="n">features_df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
    <span class="n">method</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;harmony&quot;</span><span class="p">,</span>
    <span class="n">batch_var</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">features</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">output_path</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Path</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="c1"># ComBat parameters</span>
    <span class="n">covariates</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="c1"># Harmony parameters</span>
    <span class="n">n_clusters</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">30</span><span class="p">,</span>
    <span class="n">sigma</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">,</span>
    <span class="n">theta</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">2.0</span><span class="p">,</span>
    <span class="n">lambda_reg</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
    <span class="n">max_iter</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
    <span class="n">pca_variance</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.9</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Apply batch correction to feature data.</span>
<span class="sd">    </span>
<span class="sd">    This function applies batch correction using ComBat or Harmony to remove</span>
<span class="sd">    technical variation (batch effects) between different files or batches.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        features_df: DataFrame with cell features</span>
<span class="sd">        method: Batch correction method (&#39;combat&#39; or &#39;harmony&#39;)</span>
<span class="sd">        batch_var: Column name containing batch identifiers. If None, auto-detects</span>
<span class="sd">        features: List of feature column names to correct. If None, auto-detects</span>
<span class="sd">        output_path: Optional path to save corrected features CSV</span>
<span class="sd">        covariates: Optional list of covariate column names (ComBat only)</span>
<span class="sd">        n_clusters: Number of Harmony clusters (default: 30)</span>
<span class="sd">        sigma: Width of soft kmeans clusters for Harmony (default: 0.1)</span>
<span class="sd">        theta: Diversity clustering penalty parameter for Harmony (default: 2.0)</span>
<span class="sd">        lambda_reg: Regularization parameter for Harmony (default: 1.0)</span>
<span class="sd">        max_iter: Maximum number of iterations for Harmony (default: 10)</span>
<span class="sd">        pca_variance: Proportion of variance to retain in PCA for Harmony (default: 0.9)</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        DataFrame with corrected features (all original columns preserved)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Auto-detect batch variable if not provided</span>
    <span class="k">if</span> <span class="n">batch_var</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">batch_var</span> <span class="o">=</span> <span class="n">detect_batch_variable</span><span class="p">(</span><span class="n">features_df</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">batch_var</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;No batch variable found. Please specify batch_var or ensure &quot;</span>
                <span class="s2">&quot;dataframe contains &#39;source_file&#39; or &#39;acquisition_id&#39; column.&quot;</span>
            <span class="p">)</span>
    
    <span class="c1"># Auto-detect features if not provided</span>
    <span class="k">if</span> <span class="n">features</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Exclude non-feature columns</span>
        <span class="n">exclude_cols</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;label&#39;</span><span class="p">,</span> <span class="s1">&#39;acquisition_id&#39;</span><span class="p">,</span> <span class="s1">&#39;acquisition_name&#39;</span><span class="p">,</span> <span class="s1">&#39;well&#39;</span><span class="p">,</span> <span class="s1">&#39;cluster&#39;</span><span class="p">,</span>
            <span class="s1">&#39;cell_id&#39;</span><span class="p">,</span> <span class="s1">&#39;centroid_x&#39;</span><span class="p">,</span> <span class="s1">&#39;centroid_y&#39;</span><span class="p">,</span> <span class="s1">&#39;source_file&#39;</span><span class="p">,</span> <span class="s1">&#39;source_well&#39;</span><span class="p">,</span>
            <span class="n">batch_var</span>
        <span class="p">}</span>
        <span class="n">features</span> <span class="o">=</span> <span class="p">[</span><span class="n">col</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">features_df</span><span class="o">.</span><span class="n">columns</span> <span class="k">if</span> <span class="n">col</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">exclude_cols</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">features</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No features found to correct. Please specify features.&quot;</span><span class="p">)</span>
    
    <span class="c1"># Validate inputs</span>
    <span class="n">validate_batch_correction_inputs</span><span class="p">(</span><span class="n">features_df</span><span class="p">,</span> <span class="n">batch_var</span><span class="p">,</span> <span class="n">features</span><span class="p">)</span>
    
    <span class="c1"># Apply correction based on method</span>
    <span class="k">if</span> <span class="n">method</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;combat&#39;</span><span class="p">:</span>
        <span class="n">corrected_df</span> <span class="o">=</span> <span class="n">apply_combat_correction</span><span class="p">(</span>
            <span class="n">features_df</span><span class="p">,</span>
            <span class="n">batch_var</span><span class="p">,</span>
            <span class="n">features</span><span class="p">,</span>
            <span class="n">covariates</span><span class="o">=</span><span class="n">covariates</span>
        <span class="p">)</span>
    <span class="k">elif</span> <span class="n">method</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;harmony&#39;</span><span class="p">:</span>
        <span class="n">corrected_df</span> <span class="o">=</span> <span class="n">apply_harmony_correction</span><span class="p">(</span>
            <span class="n">features_df</span><span class="p">,</span>
            <span class="n">batch_var</span><span class="p">,</span>
            <span class="n">features</span><span class="p">,</span>
            <span class="n">n_clusters</span><span class="o">=</span><span class="n">n_clusters</span><span class="p">,</span>
            <span class="n">sigma</span><span class="o">=</span><span class="n">sigma</span><span class="p">,</span>
            <span class="n">theta</span><span class="o">=</span><span class="n">theta</span><span class="p">,</span>
            <span class="n">lambda_reg</span><span class="o">=</span><span class="n">lambda_reg</span><span class="p">,</span>
            <span class="n">max_iter</span><span class="o">=</span><span class="n">max_iter</span><span class="p">,</span>
            <span class="n">pca_variance</span><span class="o">=</span><span class="n">pca_variance</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unknown batch correction method: </span><span class="si">{</span><span class="n">method</span><span class="si">}</span><span class="s2">. Must be &#39;combat&#39; or &#39;harmony&#39;&quot;</span><span class="p">)</span>
    
    <span class="c1"># Save output if path is provided</span>
    <span class="k">if</span> <span class="n">output_path</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">output_path</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">output_path</span><span class="p">)</span>
        <span class="n">corrected_df</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">output_path</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">corrected_df</span></div>



<div class="viewcode-block" id="pixel_correlation">
<a class="viewcode-back" href="../../api_core.html#openimc.core.pixel_correlation">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">pixel_correlation</span><span class="p">(</span>
    <span class="n">loader</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">MCDLoader</span><span class="p">,</span> <span class="n">OMETIFFLoader</span><span class="p">],</span>
    <span class="n">acquisition</span><span class="p">:</span> <span class="n">AcquisitionInfo</span><span class="p">,</span>
    <span class="n">channels</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
    <span class="n">mask</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">multiple_testing_correction</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute pixel-level correlations between marker pairs.</span>
<span class="sd">    </span>
<span class="sd">    This function computes Spearman correlation coefficients for all pairs of</span>
<span class="sd">    markers at the pixel level. Can analyze within cell masks or entire ROI.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        loader: Data loader (MCDLoader or OMETIFFLoader)</span>
<span class="sd">        acquisition: Acquisition information</span>
<span class="sd">        channels: List of channel names to analyze</span>
<span class="sd">        mask: Optional segmentation mask. If provided, only pixels within cells are analyzed</span>
<span class="sd">        multiple_testing_correction: Optional correction method (&#39;bonferroni&#39;, &#39;fdr_bh&#39;, etc.)</span>
<span class="sd">            If provided, applies correction to p-values</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        DataFrame with columns: marker1, marker2, correlation, p_value, n_pixels</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">scipy.stats</span><span class="w"> </span><span class="kn">import</span> <span class="n">spearmanr</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">statsmodels.stats.multitest</span><span class="w"> </span><span class="kn">import</span> <span class="n">multipletests</span>
    
    <span class="c1"># Load image stack for all channels</span>
    <span class="n">img_stack</span> <span class="o">=</span> <span class="n">loader</span><span class="o">.</span><span class="n">get_all_channels</span><span class="p">(</span><span class="n">acquisition</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
    
    <span class="c1"># Determine shape - loaders return HWC format (H, W, C)</span>
    <span class="k">if</span> <span class="n">img_stack</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="n">height</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">n_channels</span> <span class="o">=</span> <span class="n">img_stack</span><span class="o">.</span><span class="n">shape</span>
    <span class="k">elif</span> <span class="n">img_stack</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="c1"># Single channel</span>
        <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;marker1&#39;</span><span class="p">,</span> <span class="s1">&#39;marker2&#39;</span><span class="p">,</span> <span class="s1">&#39;correlation&#39;</span><span class="p">,</span> <span class="s1">&#39;p_value&#39;</span><span class="p">,</span> <span class="s1">&#39;n_pixels&#39;</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;marker1&#39;</span><span class="p">,</span> <span class="s1">&#39;marker2&#39;</span><span class="p">,</span> <span class="s1">&#39;correlation&#39;</span><span class="p">,</span> <span class="s1">&#39;p_value&#39;</span><span class="p">,</span> <span class="s1">&#39;n_pixels&#39;</span><span class="p">])</span>
    
    <span class="c1"># Ensure we have the right number of channels</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">channels</span><span class="p">)</span> <span class="o">!=</span> <span class="n">n_channels</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">channels</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">n_channels</span><span class="p">:</span>
            <span class="n">channels</span> <span class="o">=</span> <span class="n">channels</span><span class="p">[:</span><span class="n">n_channels</span><span class="p">]</span>
    
    <span class="c1"># Flatten images and apply mask if provided</span>
    <span class="n">pixel_data</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">channel</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">channels</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="n">n_channels</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="c1"># Extract channel from HWC format: (H, W, C) -&gt; (H, W)</span>
        <span class="n">channel_img</span> <span class="o">=</span> <span class="n">img_stack</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">i</span><span class="p">]</span> <span class="k">if</span> <span class="n">img_stack</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">3</span> <span class="k">else</span> <span class="n">img_stack</span>
        
        <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Only use pixels within cells</span>
            <span class="k">if</span> <span class="n">mask</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">channel_img</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
                <span class="n">cell_mask</span> <span class="o">=</span> <span class="n">mask</span> <span class="o">&gt;</span> <span class="mi">0</span>
                <span class="n">pixels</span> <span class="o">=</span> <span class="n">channel_img</span><span class="p">[</span><span class="n">cell_mask</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Mask dimensions don&#39;t match, skip mask</span>
                <span class="n">pixels</span> <span class="o">=</span> <span class="n">channel_img</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Use all pixels</span>
            <span class="n">pixels</span> <span class="o">=</span> <span class="n">channel_img</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        
        <span class="c1"># Remove NaN and infinite values</span>
        <span class="n">pixels</span> <span class="o">=</span> <span class="n">pixels</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">pixels</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">pixels</span><span class="p">)]</span>
        <span class="n">pixel_data</span><span class="p">[</span><span class="n">channel</span><span class="p">]</span> <span class="o">=</span> <span class="n">pixels</span>
    
    <span class="c1"># Compute pairwise correlations</span>
    <span class="n">correlations</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">channel_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">pixel_data</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ch1</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">channel_list</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">ch2</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">channel_list</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="n">j</span><span class="p">:</span>  <span class="c1"># Only compute upper triangle</span>
                <span class="k">continue</span>
            
            <span class="n">data1</span> <span class="o">=</span> <span class="n">pixel_data</span><span class="p">[</span><span class="n">ch1</span><span class="p">]</span>
            <span class="n">data2</span> <span class="o">=</span> <span class="n">pixel_data</span><span class="p">[</span><span class="n">ch2</span><span class="p">]</span>
            
            <span class="c1"># Ensure same length (take minimum)</span>
            <span class="n">min_len</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data1</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">data2</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">min_len</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>  <span class="c1"># Need at least 3 points for correlation</span>
                <span class="k">continue</span>
            
            <span class="n">data1</span> <span class="o">=</span> <span class="n">data1</span><span class="p">[:</span><span class="n">min_len</span><span class="p">]</span>
            <span class="n">data2</span> <span class="o">=</span> <span class="n">data2</span><span class="p">[:</span><span class="n">min_len</span><span class="p">]</span>
            
            <span class="c1"># Compute Spearman correlation</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">corr_coef</span><span class="p">,</span> <span class="n">p_value</span> <span class="o">=</span> <span class="n">spearmanr</span><span class="p">(</span><span class="n">data1</span><span class="p">,</span> <span class="n">data2</span><span class="p">)</span>
                
                <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">corr_coef</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">corr_coef</span><span class="p">):</span>
                    <span class="n">correlations</span><span class="o">.</span><span class="n">append</span><span class="p">({</span>
                        <span class="s1">&#39;marker1&#39;</span><span class="p">:</span> <span class="n">ch1</span><span class="p">,</span>
                        <span class="s1">&#39;marker2&#39;</span><span class="p">:</span> <span class="n">ch2</span><span class="p">,</span>
                        <span class="s1">&#39;correlation&#39;</span><span class="p">:</span> <span class="n">corr_coef</span><span class="p">,</span>
                        <span class="s1">&#39;p_value&#39;</span><span class="p">:</span> <span class="n">p_value</span><span class="p">,</span>
                        <span class="s1">&#39;n_pixels&#39;</span><span class="p">:</span> <span class="n">min_len</span>
                    <span class="p">})</span>
            <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                <span class="k">continue</span>
    
    <span class="c1"># Create results dataframe</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">correlations</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;marker1&#39;</span><span class="p">,</span> <span class="s1">&#39;marker2&#39;</span><span class="p">,</span> <span class="s1">&#39;correlation&#39;</span><span class="p">,</span> <span class="s1">&#39;p_value&#39;</span><span class="p">,</span> <span class="s1">&#39;n_pixels&#39;</span><span class="p">])</span>
    
    <span class="n">results_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">correlations</span><span class="p">)</span>
    
    <span class="c1"># Apply multiple testing correction if requested</span>
    <span class="k">if</span> <span class="n">multiple_testing_correction</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">results_df</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">p_values</span> <span class="o">=</span> <span class="n">results_df</span><span class="p">[</span><span class="s1">&#39;p_value&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">p_corrected</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">multipletests</span><span class="p">(</span><span class="n">p_values</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">multiple_testing_correction</span><span class="p">)</span>
            <span class="n">results_df</span><span class="p">[</span><span class="s1">&#39;p_value_corrected&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_corrected</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="c1"># If correction fails, just continue without it</span>
            <span class="k">pass</span>
    
    <span class="k">return</span> <span class="n">results_df</span></div>



<div class="viewcode-block" id="qc_analysis">
<a class="viewcode-back" href="../../api_core.html#openimc.core.qc_analysis">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">qc_analysis</span><span class="p">(</span>
    <span class="n">loader</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">MCDLoader</span><span class="p">,</span> <span class="n">OMETIFFLoader</span><span class="p">],</span>
    <span class="n">acquisition</span><span class="p">:</span> <span class="n">AcquisitionInfo</span><span class="p">,</span>
    <span class="n">channels</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
    <span class="n">mode</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;pixel&quot;</span><span class="p">,</span>
    <span class="n">mask</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Perform quality control analysis on IMC data.</span>
<span class="sd">    </span>
<span class="sd">    This function calculates QC metrics including SNR (Signal-to-Noise Ratio),</span>
<span class="sd">    intensity statistics, and coverage metrics. Can analyze at pixel level or</span>
<span class="sd">    cell level (if mask is provided).</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        loader: Data loader (MCDLoader or OMETIFFLoader)</span>
<span class="sd">        acquisition: Acquisition information</span>
<span class="sd">        channels: List of channel names to analyze</span>
<span class="sd">        mode: Analysis mode (&#39;pixel&#39; or &#39;cell&#39;)</span>
<span class="sd">        mask: Optional segmentation mask (required for &#39;cell&#39; mode)</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        DataFrame with QC metrics per channel</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Optional scikit-image for Otsu thresholding</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">skimage.filters</span><span class="w"> </span><span class="kn">import</span> <span class="n">threshold_otsu</span>
        <span class="n">_HAVE_SCIKIT_IMAGE</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
        <span class="n">_HAVE_SCIKIT_IMAGE</span> <span class="o">=</span> <span class="kc">False</span>
    
    <span class="k">def</span><span class="w"> </span><span class="nf">_calculate_snr</span><span class="p">(</span><span class="n">signal_mean</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">background_mean</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">background_std</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
                      <span class="n">img_min</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">img_max</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calculate Signal-to-Noise Ratio with robust handling.&quot;&quot;&quot;</span>
        <span class="n">signal_diff</span> <span class="o">=</span> <span class="n">signal_mean</span> <span class="o">-</span> <span class="n">background_mean</span>
        <span class="n">min_std_relative</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">background_mean</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.001</span>
        <span class="n">min_std_absolute</span> <span class="o">=</span> <span class="mf">1e-6</span>
        <span class="n">min_std_range</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">if</span> <span class="n">img_min</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">img_max</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">img_range</span> <span class="o">=</span> <span class="n">img_max</span> <span class="o">-</span> <span class="n">img_min</span>
            <span class="k">if</span> <span class="n">img_range</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">min_std_range</span> <span class="o">=</span> <span class="n">img_range</span> <span class="o">*</span> <span class="mf">0.0001</span>
        <span class="n">min_std</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">background_std</span><span class="p">,</span> <span class="n">min_std_relative</span><span class="p">,</span> <span class="n">min_std_absolute</span><span class="p">,</span> <span class="n">min_std_range</span><span class="p">)</span>
        <span class="n">snr</span> <span class="o">=</span> <span class="n">signal_diff</span> <span class="o">/</span> <span class="n">min_std</span>
        <span class="k">return</span> <span class="n">snr</span>
    
    <span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="k">for</span> <span class="n">channel</span> <span class="ow">in</span> <span class="n">channels</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># Load image</span>
            <span class="n">img</span> <span class="o">=</span> <span class="n">loader</span><span class="o">.</span><span class="n">get_image</span><span class="p">(</span><span class="n">acquisition</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">channel</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">img</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">continue</span>
            
            <span class="n">img_flat</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
            <span class="n">img_min</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">img_flat</span><span class="p">))</span>
            <span class="n">img_max</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">img_flat</span><span class="p">))</span>
            <span class="n">img_mean</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">img_flat</span><span class="p">))</span>
            <span class="n">img_std</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">img_flat</span><span class="p">))</span>
            <span class="n">img_median</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">img_flat</span><span class="p">))</span>
            
            <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;pixel&quot;</span><span class="p">:</span>
                <span class="c1"># Pixel-level QC using Otsu threshold</span>
                <span class="k">if</span> <span class="n">_HAVE_SCIKIT_IMAGE</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">threshold</span> <span class="o">=</span> <span class="n">threshold_otsu</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>
                        <span class="n">signal_mask</span> <span class="o">=</span> <span class="n">img</span> <span class="o">&gt;</span> <span class="n">threshold</span>
                        <span class="n">background_mask</span> <span class="o">=</span> <span class="n">img</span> <span class="o">&lt;=</span> <span class="n">threshold</span>
                        
                        <span class="n">signal_mean</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">img</span><span class="p">[</span><span class="n">signal_mask</span><span class="p">]))</span> <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">signal_mask</span><span class="p">)</span> <span class="k">else</span> <span class="n">img_mean</span>
                        <span class="n">background_mean</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">img</span><span class="p">[</span><span class="n">background_mask</span><span class="p">]))</span> <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">background_mask</span><span class="p">)</span> <span class="k">else</span> <span class="n">img_mean</span>
                        <span class="n">background_std</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">img</span><span class="p">[</span><span class="n">background_mask</span><span class="p">]))</span> <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">background_mask</span><span class="p">)</span> <span class="k">else</span> <span class="n">img_std</span>
                        
                        <span class="n">snr</span> <span class="o">=</span> <span class="n">_calculate_snr</span><span class="p">(</span><span class="n">signal_mean</span><span class="p">,</span> <span class="n">background_mean</span><span class="p">,</span> <span class="n">background_std</span><span class="p">,</span> <span class="n">img_min</span><span class="p">,</span> <span class="n">img_max</span><span class="p">)</span>
                        <span class="n">coverage</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">signal_mask</span><span class="p">)</span> <span class="o">/</span> <span class="n">signal_mask</span><span class="o">.</span><span class="n">size</span><span class="p">)</span> <span class="k">if</span> <span class="n">signal_mask</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="mf">0.0</span>
                    <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                        <span class="c1"># Fallback if Otsu fails</span>
                        <span class="n">signal_mean</span> <span class="o">=</span> <span class="n">img_mean</span>
                        <span class="n">background_mean</span> <span class="o">=</span> <span class="n">img_mean</span>
                        <span class="n">background_std</span> <span class="o">=</span> <span class="n">img_std</span>
                        <span class="n">snr</span> <span class="o">=</span> <span class="mf">0.0</span>
                        <span class="n">coverage</span> <span class="o">=</span> <span class="mf">0.0</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># No scikit-image, use simple statistics</span>
                    <span class="n">signal_mean</span> <span class="o">=</span> <span class="n">img_mean</span>
                    <span class="n">background_mean</span> <span class="o">=</span> <span class="n">img_mean</span>
                    <span class="n">background_std</span> <span class="o">=</span> <span class="n">img_std</span>
                    <span class="n">snr</span> <span class="o">=</span> <span class="mf">0.0</span>
                    <span class="n">coverage</span> <span class="o">=</span> <span class="mf">0.0</span>
                
                <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">({</span>
                    <span class="s1">&#39;acquisition_id&#39;</span><span class="p">:</span> <span class="n">acquisition</span><span class="o">.</span><span class="n">id</span><span class="p">,</span>
                    <span class="s1">&#39;acquisition_name&#39;</span><span class="p">:</span> <span class="n">acquisition</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                    <span class="s1">&#39;channel&#39;</span><span class="p">:</span> <span class="n">channel</span><span class="p">,</span>
                    <span class="s1">&#39;mode&#39;</span><span class="p">:</span> <span class="s1">&#39;pixel&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;snr&#39;</span><span class="p">:</span> <span class="n">snr</span><span class="p">,</span>
                    <span class="s1">&#39;signal_mean&#39;</span><span class="p">:</span> <span class="n">signal_mean</span><span class="p">,</span>
                    <span class="s1">&#39;background_mean&#39;</span><span class="p">:</span> <span class="n">background_mean</span><span class="p">,</span>
                    <span class="s1">&#39;background_std&#39;</span><span class="p">:</span> <span class="n">background_std</span><span class="p">,</span>
                    <span class="s1">&#39;intensity_mean&#39;</span><span class="p">:</span> <span class="n">img_mean</span><span class="p">,</span>
                    <span class="s1">&#39;intensity_std&#39;</span><span class="p">:</span> <span class="n">img_std</span><span class="p">,</span>
                    <span class="s1">&#39;intensity_median&#39;</span><span class="p">:</span> <span class="n">img_median</span><span class="p">,</span>
                    <span class="s1">&#39;intensity_min&#39;</span><span class="p">:</span> <span class="n">img_min</span><span class="p">,</span>
                    <span class="s1">&#39;intensity_max&#39;</span><span class="p">:</span> <span class="n">img_max</span><span class="p">,</span>
                    <span class="s1">&#39;coverage&#39;</span><span class="p">:</span> <span class="n">coverage</span>
                <span class="p">})</span>
            
            <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;cell&quot;</span><span class="p">:</span>
                <span class="c1"># Cell-level QC using segmentation mask</span>
                <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">continue</span>
                
                <span class="k">if</span> <span class="n">mask</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
                    <span class="k">continue</span>
                
                <span class="c1"># Calculate metrics per cell</span>
                <span class="n">cell_ids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">mask</span><span class="p">[</span><span class="n">mask</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">])</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cell_ids</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">continue</span>
                
                <span class="n">cell_intensities</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">cell_id</span> <span class="ow">in</span> <span class="n">cell_ids</span><span class="p">:</span>
                    <span class="n">cell_mask</span> <span class="o">=</span> <span class="n">mask</span> <span class="o">==</span> <span class="n">cell_id</span>
                    <span class="n">cell_intensity</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">img</span><span class="p">[</span><span class="n">cell_mask</span><span class="p">])</span>
                    <span class="n">cell_intensities</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cell_intensity</span><span class="p">)</span>
                
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cell_intensities</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">continue</span>
                
                <span class="n">cell_intensities</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">cell_intensities</span><span class="p">)</span>
                <span class="n">signal_mean</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">cell_intensities</span><span class="p">))</span>
                <span class="n">signal_std</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">cell_intensities</span><span class="p">))</span>
                
                <span class="c1"># Background is pixels outside cells</span>
                <span class="n">background_mask</span> <span class="o">=</span> <span class="n">mask</span> <span class="o">==</span> <span class="mi">0</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">background_mask</span><span class="p">):</span>
                    <span class="n">background_mean</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">img</span><span class="p">[</span><span class="n">background_mask</span><span class="p">]))</span>
                    <span class="n">background_std</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">img</span><span class="p">[</span><span class="n">background_mask</span><span class="p">]))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">background_mean</span> <span class="o">=</span> <span class="n">img_mean</span>
                    <span class="n">background_std</span> <span class="o">=</span> <span class="n">img_std</span>
                
                <span class="n">snr</span> <span class="o">=</span> <span class="n">_calculate_snr</span><span class="p">(</span><span class="n">signal_mean</span><span class="p">,</span> <span class="n">background_mean</span><span class="p">,</span> <span class="n">background_std</span><span class="p">,</span> <span class="n">img_min</span><span class="p">,</span> <span class="n">img_max</span><span class="p">)</span>
                
                <span class="c1"># Coverage: fraction of pixels covered by cells</span>
                <span class="n">coverage</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">mask</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">/</span> <span class="n">mask</span><span class="o">.</span><span class="n">size</span><span class="p">)</span> <span class="k">if</span> <span class="n">mask</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="mf">0.0</span>
                
                <span class="c1"># Cell density: cells per unit area (assuming pixels)</span>
                <span class="n">cell_density</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">cell_ids</span><span class="p">)</span> <span class="o">/</span> <span class="n">mask</span><span class="o">.</span><span class="n">size</span><span class="p">)</span> <span class="k">if</span> <span class="n">mask</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="mf">0.0</span>
                
                <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">({</span>
                    <span class="s1">&#39;acquisition_id&#39;</span><span class="p">:</span> <span class="n">acquisition</span><span class="o">.</span><span class="n">id</span><span class="p">,</span>
                    <span class="s1">&#39;acquisition_name&#39;</span><span class="p">:</span> <span class="n">acquisition</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                    <span class="s1">&#39;channel&#39;</span><span class="p">:</span> <span class="n">channel</span><span class="p">,</span>
                    <span class="s1">&#39;mode&#39;</span><span class="p">:</span> <span class="s1">&#39;cell&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;snr&#39;</span><span class="p">:</span> <span class="n">snr</span><span class="p">,</span>
                    <span class="s1">&#39;signal_mean&#39;</span><span class="p">:</span> <span class="n">signal_mean</span><span class="p">,</span>
                    <span class="s1">&#39;signal_std&#39;</span><span class="p">:</span> <span class="n">signal_std</span><span class="p">,</span>
                    <span class="s1">&#39;background_mean&#39;</span><span class="p">:</span> <span class="n">background_mean</span><span class="p">,</span>
                    <span class="s1">&#39;background_std&#39;</span><span class="p">:</span> <span class="n">background_std</span><span class="p">,</span>
                    <span class="s1">&#39;intensity_mean&#39;</span><span class="p">:</span> <span class="n">img_mean</span><span class="p">,</span>
                    <span class="s1">&#39;intensity_std&#39;</span><span class="p">:</span> <span class="n">img_std</span><span class="p">,</span>
                    <span class="s1">&#39;intensity_median&#39;</span><span class="p">:</span> <span class="n">img_median</span><span class="p">,</span>
                    <span class="s1">&#39;intensity_min&#39;</span><span class="p">:</span> <span class="n">img_min</span><span class="p">,</span>
                    <span class="s1">&#39;intensity_max&#39;</span><span class="p">:</span> <span class="n">img_max</span><span class="p">,</span>
                    <span class="s1">&#39;coverage&#39;</span><span class="p">:</span> <span class="n">coverage</span><span class="p">,</span>
                    <span class="s1">&#39;cell_density&#39;</span><span class="p">:</span> <span class="n">cell_density</span><span class="p">,</span>
                    <span class="s1">&#39;n_cells&#39;</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">cell_ids</span><span class="p">)</span>
                <span class="p">})</span>
        
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="k">continue</span>
    
    <span class="k">if</span> <span class="ow">not</span> <span class="n">results</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
    
    <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">results</span><span class="p">)</span></div>



<div class="viewcode-block" id="spillover_correction">
<a class="viewcode-back" href="../../api_core.html#openimc.core.spillover_correction">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">spillover_correction</span><span class="p">(</span>
    <span class="n">features_df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
    <span class="n">spillover_matrix</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Path</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">],</span>
    <span class="n">method</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;pgd&quot;</span><span class="p">,</span>
    <span class="n">arcsinh_cofactor</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">channel_map</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">output_path</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Path</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Apply spillover correction to feature data.</span>
<span class="sd">    </span>
<span class="sd">    This function applies CATALYST-like spillover compensation to remove</span>
<span class="sd">    spectral overlap between channels in IMC data.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        features_df: DataFrame with cell features (cells x channels)</span>
<span class="sd">        spillover_matrix: Path to spillover matrix CSV or DataFrame</span>
<span class="sd">        method: Compensation method (&#39;nnls&#39; or &#39;pgd&#39;, default: &#39;pgd&#39;)</span>
<span class="sd">        arcsinh_cofactor: Optional cofactor for arcsinh transformation</span>
<span class="sd">        channel_map: Optional mapping from feature column names to spillover matrix channel names</span>
<span class="sd">        output_path: Optional path to save corrected features CSV</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        DataFrame with corrected features</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Load spillover matrix if path provided</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">spillover_matrix</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">Path</span><span class="p">)):</span>
        <span class="n">S</span> <span class="o">=</span> <span class="n">load_spillover</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">spillover_matrix</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">S</span> <span class="o">=</span> <span class="n">spillover_matrix</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    
    <span class="c1"># Extract intensity features (columns that match spillover matrix channels)</span>
    <span class="c1"># Auto-detect intensity columns if not all columns are features</span>
    <span class="n">intensity_cols</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">features_df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">S</span><span class="o">.</span><span class="n">columns</span> <span class="ow">or</span> <span class="p">(</span><span class="n">channel_map</span> <span class="ow">and</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">channel_map</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
            <span class="n">intensity_cols</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">col</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="ow">not</span> <span class="n">intensity_cols</span><span class="p">:</span>
        <span class="c1"># Try to find intensity columns by pattern (e.g., channel names)</span>
        <span class="c1"># This is a fallback - ideally user should specify</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;No matching channels found between features and spillover matrix. &quot;</span>
            <span class="s2">&quot;Please ensure channel names match or provide channel_map.&quot;</span>
        <span class="p">)</span>
    
    <span class="c1"># Apply compensation</span>
    <span class="n">comp_counts</span><span class="p">,</span> <span class="n">comp_asinh</span> <span class="o">=</span> <span class="n">compensate_counts</span><span class="p">(</span>
        <span class="n">features_df</span><span class="p">[</span><span class="n">intensity_cols</span><span class="p">],</span>
        <span class="n">S</span><span class="p">,</span>
        <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span>
        <span class="n">arcsinh_cofactor</span><span class="o">=</span><span class="n">arcsinh_cofactor</span><span class="p">,</span>
        <span class="n">channel_map</span><span class="o">=</span><span class="n">channel_map</span><span class="p">,</span>
        <span class="n">strict_align</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">return_all_channels</span><span class="o">=</span><span class="kc">True</span>
    <span class="p">)</span>
    
    <span class="c1"># Create result dataframe with all original columns</span>
    <span class="n">result_df</span> <span class="o">=</span> <span class="n">features_df</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">result_df</span><span class="p">[</span><span class="n">intensity_cols</span><span class="p">]</span> <span class="o">=</span> <span class="n">comp_counts</span><span class="p">[</span><span class="n">intensity_cols</span><span class="p">]</span>
    
    <span class="c1"># Add arcsinh-transformed version if requested</span>
    <span class="k">if</span> <span class="n">comp_asinh</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">intensity_cols</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">comp_asinh</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                <span class="n">result_df</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">col</span><span class="si">}</span><span class="s2">_arcsinh&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">comp_asinh</span><span class="p">[</span><span class="n">col</span><span class="p">]</span>
    
    <span class="c1"># Save output if path is provided</span>
    <span class="k">if</span> <span class="n">output_path</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">output_path</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">output_path</span><span class="p">)</span>
        <span class="n">result_df</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">output_path</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">result_df</span></div>



<div class="viewcode-block" id="generate_spillover_matrix">
<a class="viewcode-back" href="../../api_core.html#openimc.core.generate_spillover_matrix">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">generate_spillover_matrix</span><span class="p">(</span>
    <span class="n">mcd_path</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Path</span><span class="p">],</span>
    <span class="n">donor_label_per_acq</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">cap</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.3</span><span class="p">,</span>
    <span class="n">aggregate</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;median&quot;</span><span class="p">,</span>
    <span class="n">channel_name_field</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;name&quot;</span><span class="p">,</span>
    <span class="n">p_low</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">90.0</span><span class="p">,</span>
    <span class="n">p_high_clip</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">99.9</span><span class="p">,</span>
    <span class="n">output_path</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Path</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Generate spillover matrix from single-stain control MCD file.</span>
<span class="sd">    </span>
<span class="sd">    This function analyzes pixel-level data from single-stain control acquisitions</span>
<span class="sd">    to estimate spillover coefficients between channels.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        mcd_path: Path to MCD file containing single-stain controls</span>
<span class="sd">        donor_label_per_acq: Mapping from acquisition ID/index to donor channel name</span>
<span class="sd">        cap: Maximum spillover coefficient (default: 0.3)</span>
<span class="sd">        aggregate: Aggregation method when multiple acquisitions per donor (&#39;median&#39; or &#39;mean&#39;)</span>
<span class="sd">        channel_name_field: Field to use for channel names (&#39;name&#39; or &#39;fullname&#39;, default: &#39;name&#39;)</span>
<span class="sd">        p_low: Lower percentile for foreground selection (default: 90.0)</span>
<span class="sd">        p_high_clip: Upper percentile for clipping (default: 99.9)</span>
<span class="sd">        output_path: Optional path to save spillover matrix CSV</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        Tuple of (spillover_matrix_df, qc_metrics_df)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">S_df</span><span class="p">,</span> <span class="n">qc_df</span> <span class="o">=</span> <span class="n">build_spillover_from_comp_mcd</span><span class="p">(</span>
        <span class="nb">str</span><span class="p">(</span><span class="n">mcd_path</span><span class="p">),</span>
        <span class="n">donor_label_per_acq</span><span class="o">=</span><span class="n">donor_label_per_acq</span><span class="p">,</span>
        <span class="n">cap</span><span class="o">=</span><span class="n">cap</span><span class="p">,</span>
        <span class="n">aggregate</span><span class="o">=</span><span class="n">aggregate</span><span class="p">,</span>
        <span class="n">channel_name_field</span><span class="o">=</span><span class="n">channel_name_field</span><span class="p">,</span>
        <span class="n">p_low</span><span class="o">=</span><span class="n">p_low</span><span class="p">,</span>
        <span class="n">p_high_clip</span><span class="o">=</span><span class="n">p_high_clip</span>
    <span class="p">)</span>
    
    <span class="c1"># Save output if path is provided</span>
    <span class="k">if</span> <span class="n">output_path</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">output_path</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">output_path</span><span class="p">)</span>
        <span class="n">S_df</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">output_path</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">qc_path</span> <span class="o">=</span> <span class="n">output_path</span><span class="o">.</span><span class="n">parent</span> <span class="o">/</span> <span class="p">(</span><span class="n">output_path</span><span class="o">.</span><span class="n">stem</span> <span class="o">+</span> <span class="s1">&#39;_qc.csv&#39;</span><span class="p">)</span>
        <span class="n">qc_df</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">qc_path</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">S_df</span><span class="p">,</span> <span class="n">qc_df</span></div>



<div class="viewcode-block" id="deconvolution">
<a class="viewcode-back" href="../../api_core.html#openimc.core.deconvolution">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">deconvolution</span><span class="p">(</span>
    <span class="n">loader</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">MCDLoader</span><span class="p">,</span> <span class="n">OMETIFFLoader</span><span class="p">],</span>
    <span class="n">acquisition</span><span class="p">:</span> <span class="n">AcquisitionInfo</span><span class="p">,</span>
    <span class="n">output_dir</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Path</span><span class="p">],</span>
    <span class="n">x0</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">7.0</span><span class="p">,</span>
    <span class="n">iterations</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
    <span class="n">output_format</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;float&quot;</span><span class="p">,</span>
    <span class="n">loader_path</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Path</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">source_file_path</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Path</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">unique_acq_id</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Path</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Apply Richardson-Lucy deconvolution to high resolution IMC images.</span>
<span class="sd">    </span>
<span class="sd">    This function applies deconvolution optimized for high resolution IMC</span>
<span class="sd">    images with step sizes of 333 nm and 500 nm.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        loader: Data loader (MCDLoader or OMETIFFLoader)</span>
<span class="sd">        acquisition: Acquisition information</span>
<span class="sd">        output_dir: Output directory for deconvolved images</span>
<span class="sd">        x0: Parameter for kernel calculation (default: 7.0)</span>
<span class="sd">        iterations: Number of Richardson-Lucy iterations (default: 4)</span>
<span class="sd">        output_format: Output format (&#39;float&#39; or &#39;uint16&#39;, default: &#39;float&#39;)</span>
<span class="sd">        loader_path: Optional explicit path to loader file/directory (if loader doesn&#39;t have file_path/directory attribute)</span>
<span class="sd">        source_file_path: Optional source file path for filename generation (defaults to loader_path)</span>
<span class="sd">        unique_acq_id: Optional unique acquisition ID for filename generation (defaults to acquisition.id)</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        Path to deconvolved OME-TIFF file</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">openimc.processing.deconvolution_worker</span><span class="w"> </span><span class="kn">import</span> <span class="n">deconvolve_acquisition</span>
    
    <span class="c1"># Get loader path</span>
    <span class="k">if</span> <span class="n">loader_path</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">loader</span><span class="p">,</span> <span class="s1">&#39;file_path&#39;</span><span class="p">):</span>
            <span class="n">loader_path</span> <span class="o">=</span> <span class="n">loader</span><span class="o">.</span><span class="n">file_path</span>
        <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">loader</span><span class="p">,</span> <span class="s1">&#39;directory&#39;</span><span class="p">):</span>
            <span class="n">loader_path</span> <span class="o">=</span> <span class="n">loader</span><span class="o">.</span><span class="n">directory</span>
        <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">loader</span><span class="p">,</span> <span class="s1">&#39;folder_path&#39;</span><span class="p">):</span>
            <span class="n">loader_path</span> <span class="o">=</span> <span class="n">loader</span><span class="o">.</span><span class="n">folder_path</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">loader</span><span class="p">,</span> <span class="n">MCDLoader</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">loader</span><span class="p">,</span> <span class="s1">&#39;mcd&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">loader</span><span class="o">.</span><span class="n">mcd</span><span class="p">:</span>
            <span class="c1"># Try to get path from McdFile object</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">loader</span><span class="o">.</span><span class="n">mcd</span><span class="p">,</span> <span class="s1">&#39;path&#39;</span><span class="p">):</span>
                <span class="n">loader_path</span> <span class="o">=</span> <span class="n">loader</span><span class="o">.</span><span class="n">mcd</span><span class="o">.</span><span class="n">path</span>
            <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">loader</span><span class="o">.</span><span class="n">mcd</span><span class="p">,</span> <span class="s1">&#39;filename&#39;</span><span class="p">):</span>
                <span class="n">loader_path</span> <span class="o">=</span> <span class="n">loader</span><span class="o">.</span><span class="n">mcd</span><span class="o">.</span><span class="n">filename</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot determine loader path for deconvolution. Please provide loader_path parameter.&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot determine loader path for deconvolution. Please provide loader_path parameter.&quot;</span><span class="p">)</span>
    
    <span class="n">loader_path</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">loader_path</span><span class="p">)</span>
    
    <span class="c1"># Use source_file_path if provided, otherwise use loader_path</span>
    <span class="k">if</span> <span class="n">source_file_path</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">source_file_path</span> <span class="o">=</span> <span class="n">loader_path</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">source_file_path</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">source_file_path</span><span class="p">)</span>
    
    <span class="c1"># Use unique_acq_id if provided, otherwise use acquisition.id</span>
    <span class="k">if</span> <span class="n">unique_acq_id</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">unique_acq_id</span> <span class="o">=</span> <span class="n">acquisition</span><span class="o">.</span><span class="n">id</span>
    
    <span class="c1"># Call deconvolution worker</span>
    <span class="n">output_path</span> <span class="o">=</span> <span class="n">deconvolve_acquisition</span><span class="p">(</span>
        <span class="n">loader_path</span><span class="p">,</span>
        <span class="n">acquisition</span><span class="o">.</span><span class="n">id</span><span class="p">,</span>
        <span class="nb">str</span><span class="p">(</span><span class="n">output_dir</span><span class="p">),</span>
        <span class="n">x0</span><span class="o">=</span><span class="n">x0</span><span class="p">,</span>
        <span class="n">iterations</span><span class="o">=</span><span class="n">iterations</span><span class="p">,</span>
        <span class="n">output_format</span><span class="o">=</span><span class="n">output_format</span><span class="p">,</span>
        <span class="n">channel_names</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>  <span class="c1"># Will be auto-detected</span>
        <span class="n">source_file_path</span><span class="o">=</span><span class="n">source_file_path</span><span class="p">,</span>
        <span class="n">unique_acq_id</span><span class="o">=</span><span class="n">unique_acq_id</span><span class="p">,</span>
        <span class="n">well_name</span><span class="o">=</span><span class="nb">getattr</span><span class="p">(</span><span class="n">acquisition</span><span class="p">,</span> <span class="s1">&#39;well&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="p">)</span>
    
    <span class="k">return</span> <span class="n">Path</span><span class="p">(</span><span class="n">output_path</span><span class="p">)</span></div>



<div class="viewcode-block" id="spatial_enrichment">
<a class="viewcode-back" href="../../api_core.html#openimc.core.spatial_enrichment">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">spatial_enrichment</span><span class="p">(</span>
    <span class="n">features_df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
    <span class="n">edges_df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
    <span class="n">cluster_column</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;cluster&quot;</span><span class="p">,</span>
    <span class="n">n_permutations</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span>
    <span class="n">seed</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">42</span><span class="p">,</span>
    <span class="n">roi_column</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">output_path</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Path</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute pairwise spatial enrichment between clusters.</span>
<span class="sd">    </span>
<span class="sd">    This function computes enrichment of spatial interactions between cluster</span>
<span class="sd">    pairs using permutation-based null distribution.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        features_df: DataFrame with cell features and cluster labels</span>
<span class="sd">        edges_df: DataFrame with spatial graph edges (must have &#39;cell_id_A&#39;, &#39;cell_id_B&#39;, &#39;roi_id&#39;)</span>
<span class="sd">        cluster_column: Column name containing cluster labels</span>
<span class="sd">        n_permutations: Number of permutations for null distribution (default: 100)</span>
<span class="sd">        seed: Random seed for reproducibility (default: 42)</span>
<span class="sd">        roi_column: Column name for ROI grouping (auto-detected if None)</span>
<span class="sd">        output_path: Optional path to save enrichment results CSV</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        DataFrame with enrichment results (cluster_A, cluster_B, observed, expected, p_value, z_score, etc.)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">random</span>
    
    <span class="c1"># Auto-detect ROI column</span>
    <span class="k">if</span> <span class="n">roi_column</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;acquisition_id&#39;</span><span class="p">,</span> <span class="s1">&#39;roi_id&#39;</span><span class="p">,</span> <span class="s1">&#39;roi&#39;</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">features_df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                <span class="n">roi_column</span> <span class="o">=</span> <span class="n">col</span>
                <span class="k">break</span>
    
    <span class="k">if</span> <span class="n">roi_column</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">roi_column</span> <span class="o">=</span> <span class="s1">&#39;roi_id&#39;</span>  <span class="c1"># Default for edges_df</span>
    
    <span class="c1"># Set random seed</span>
    <span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
    <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
    
    <span class="n">enrichment_results</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="c1"># Process per ROI</span>
    <span class="k">for</span> <span class="n">roi_id</span><span class="p">,</span> <span class="n">roi_df</span> <span class="ow">in</span> <span class="n">features_df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">roi_column</span><span class="p">):</span>
        <span class="n">roi_edges</span> <span class="o">=</span> <span class="n">edges_df</span><span class="p">[</span><span class="n">edges_df</span><span class="p">[</span><span class="s1">&#39;roi_id&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="nb">str</span><span class="p">(</span><span class="n">roi_id</span><span class="p">)]</span>
        
        <span class="k">if</span> <span class="n">roi_edges</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
            <span class="k">continue</span>
        
        <span class="c1"># Get unique clusters</span>
        <span class="n">unique_clusters</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">roi_df</span><span class="p">[</span><span class="n">cluster_column</span><span class="p">]</span><span class="o">.</span><span class="n">dropna</span><span class="p">()</span><span class="o">.</span><span class="n">unique</span><span class="p">())</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">unique_clusters</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">continue</span>
        
        <span class="c1"># Create cell_id to cluster mapping</span>
        <span class="n">cell_to_cluster</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">roi_df</span><span class="p">[</span><span class="s1">&#39;cell_id&#39;</span><span class="p">],</span> <span class="n">roi_df</span><span class="p">[</span><span class="n">cluster_column</span><span class="p">]))</span>
        
        <span class="c1"># Count observed edges between cluster pairs</span>
        <span class="n">observed_edges</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">roi_edges</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
            <span class="n">cell_a</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">edge</span><span class="p">[</span><span class="s1">&#39;cell_id_A&#39;</span><span class="p">])</span>
            <span class="n">cell_b</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">edge</span><span class="p">[</span><span class="s1">&#39;cell_id_B&#39;</span><span class="p">])</span>
            
            <span class="n">cluster_a</span> <span class="o">=</span> <span class="n">cell_to_cluster</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">cell_a</span><span class="p">)</span>
            <span class="n">cluster_b</span> <span class="o">=</span> <span class="n">cell_to_cluster</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">cell_b</span><span class="p">)</span>
            
            <span class="k">if</span> <span class="n">cluster_a</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">cluster_b</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">pair</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">([</span><span class="n">cluster_a</span><span class="p">,</span> <span class="n">cluster_b</span><span class="p">]))</span>
                <span class="n">observed_edges</span><span class="p">[</span><span class="n">pair</span><span class="p">]</span> <span class="o">=</span> <span class="n">observed_edges</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">pair</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
        
        <span class="c1"># Compute enrichment for each cluster pair</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">cluster_a</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">unique_clusters</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">cluster_b</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">unique_clusters</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">i</span><span class="p">:</span>
                    <span class="k">continue</span>
                
                <span class="n">pair</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">([</span><span class="n">cluster_a</span><span class="p">,</span> <span class="n">cluster_b</span><span class="p">]))</span>
                <span class="n">observed</span> <span class="o">=</span> <span class="n">observed_edges</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">pair</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
                
                <span class="c1"># Get cells in each cluster</span>
                <span class="n">cells_a</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">roi_df</span><span class="p">[</span><span class="n">roi_df</span><span class="p">[</span><span class="n">cluster_column</span><span class="p">]</span> <span class="o">==</span> <span class="n">cluster_a</span><span class="p">][</span><span class="s1">&#39;cell_id&#39;</span><span class="p">])</span>
                <span class="n">cells_b</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">roi_df</span><span class="p">[</span><span class="n">roi_df</span><span class="p">[</span><span class="n">cluster_column</span><span class="p">]</span> <span class="o">==</span> <span class="n">cluster_b</span><span class="p">][</span><span class="s1">&#39;cell_id&#39;</span><span class="p">])</span>
                
                <span class="c1"># Permutation test</span>
                <span class="n">n_a</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">cells_a</span><span class="p">)</span>
                <span class="n">n_b</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">cells_b</span><span class="p">)</span>
                <span class="n">total_edges</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">roi_edges</span><span class="p">)</span>
                
                <span class="k">if</span> <span class="n">total_edges</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">continue</span>
                
                <span class="c1"># Expected number of edges (proportional to cluster sizes)</span>
                <span class="n">expected</span> <span class="o">=</span> <span class="p">(</span><span class="n">n_a</span> <span class="o">*</span> <span class="n">n_b</span> <span class="o">/</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">roi_df</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">roi_df</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">))</span> <span class="o">*</span> <span class="n">total_edges</span>
                
                <span class="c1"># Permutation: randomly shuffle cluster labels</span>
                <span class="n">permuted_counts</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">cluster_labels</span> <span class="o">=</span> <span class="n">roi_df</span><span class="p">[</span><span class="n">cluster_column</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                
                <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_permutations</span><span class="p">):</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">cluster_labels</span><span class="p">)</span>
                    <span class="n">perm_cell_to_cluster</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">roi_df</span><span class="p">[</span><span class="s1">&#39;cell_id&#39;</span><span class="p">],</span> <span class="n">cluster_labels</span><span class="p">))</span>
                    
                    <span class="n">perm_observed</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">roi_edges</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
                        <span class="n">cell_a</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">edge</span><span class="p">[</span><span class="s1">&#39;cell_id_A&#39;</span><span class="p">])</span>
                        <span class="n">cell_b</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">edge</span><span class="p">[</span><span class="s1">&#39;cell_id_B&#39;</span><span class="p">])</span>
                        
                        <span class="n">perm_cluster_a</span> <span class="o">=</span> <span class="n">perm_cell_to_cluster</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">cell_a</span><span class="p">)</span>
                        <span class="n">perm_cluster_b</span> <span class="o">=</span> <span class="n">perm_cell_to_cluster</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">cell_b</span><span class="p">)</span>
                        
                        <span class="k">if</span> <span class="n">perm_cluster_a</span> <span class="o">==</span> <span class="n">cluster_a</span> <span class="ow">and</span> <span class="n">perm_cluster_b</span> <span class="o">==</span> <span class="n">cluster_b</span><span class="p">:</span>
                            <span class="n">perm_observed</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="k">elif</span> <span class="n">perm_cluster_a</span> <span class="o">==</span> <span class="n">cluster_b</span> <span class="ow">and</span> <span class="n">perm_cluster_b</span> <span class="o">==</span> <span class="n">cluster_a</span><span class="p">:</span>
                            <span class="n">perm_observed</span> <span class="o">+=</span> <span class="mi">1</span>
                    
                    <span class="n">permuted_counts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">perm_observed</span><span class="p">)</span>
                
                <span class="c1"># Calculate p-value and z-score</span>
                <span class="n">permuted_counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">permuted_counts</span><span class="p">)</span>
                <span class="n">p_value</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">permuted_counts</span> <span class="o">&gt;=</span> <span class="n">observed</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">n_permutations</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">z_score</span> <span class="o">=</span> <span class="p">(</span><span class="n">observed</span> <span class="o">-</span> <span class="n">expected</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">permuted_counts</span><span class="p">)</span> <span class="o">+</span> <span class="mf">1e-10</span><span class="p">)</span>
                
                <span class="n">enrichment_results</span><span class="o">.</span><span class="n">append</span><span class="p">({</span>
                    <span class="s1">&#39;roi_id&#39;</span><span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="n">roi_id</span><span class="p">),</span>
                    <span class="s1">&#39;cluster_A&#39;</span><span class="p">:</span> <span class="n">cluster_a</span><span class="p">,</span>
                    <span class="s1">&#39;cluster_B&#39;</span><span class="p">:</span> <span class="n">cluster_b</span><span class="p">,</span>
                    <span class="s1">&#39;observed&#39;</span><span class="p">:</span> <span class="n">observed</span><span class="p">,</span>
                    <span class="s1">&#39;expected&#39;</span><span class="p">:</span> <span class="n">expected</span><span class="p">,</span>
                    <span class="s1">&#39;p_value&#39;</span><span class="p">:</span> <span class="n">p_value</span><span class="p">,</span>
                    <span class="s1">&#39;z_score&#39;</span><span class="p">:</span> <span class="n">z_score</span><span class="p">,</span>
                    <span class="s1">&#39;n_permutations&#39;</span><span class="p">:</span> <span class="n">n_permutations</span>
                <span class="p">})</span>
    
    <span class="k">if</span> <span class="ow">not</span> <span class="n">enrichment_results</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
    
    <span class="n">results_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">enrichment_results</span><span class="p">)</span>
    
    <span class="c1"># Save output if path is provided</span>
    <span class="k">if</span> <span class="n">output_path</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">output_path</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">output_path</span><span class="p">)</span>
        <span class="n">results_df</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">output_path</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">results_df</span></div>



<div class="viewcode-block" id="spatial_distance_distribution">
<a class="viewcode-back" href="../../api_core.html#openimc.core.spatial_distance_distribution">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">spatial_distance_distribution</span><span class="p">(</span>
    <span class="n">features_df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
    <span class="n">edges_df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
    <span class="n">cluster_column</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;cluster&quot;</span><span class="p">,</span>
    <span class="n">roi_column</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">output_path</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Path</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute distance distributions between clusters.</span>
<span class="sd">    </span>
<span class="sd">    This function computes the distribution of spatial distances between</span>
<span class="sd">    cells of different clusters.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        features_df: DataFrame with cell features and cluster labels</span>
<span class="sd">        edges_df: DataFrame with spatial graph edges (must have &#39;cell_id_A&#39;, &#39;cell_id_B&#39;, &#39;distance_um&#39;, &#39;roi_id&#39;)</span>
<span class="sd">        cluster_column: Column name containing cluster labels</span>
<span class="sd">        roi_column: Column name for ROI grouping (auto-detected if None)</span>
<span class="sd">        output_path: Optional path to save distance distribution results CSV</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        DataFrame with distance distribution statistics per cluster pair</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Auto-detect ROI column</span>
    <span class="k">if</span> <span class="n">roi_column</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;acquisition_id&#39;</span><span class="p">,</span> <span class="s1">&#39;roi_id&#39;</span><span class="p">,</span> <span class="s1">&#39;roi&#39;</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">features_df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                <span class="n">roi_column</span> <span class="o">=</span> <span class="n">col</span>
                <span class="k">break</span>
    
    <span class="k">if</span> <span class="n">roi_column</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">roi_column</span> <span class="o">=</span> <span class="s1">&#39;roi_id&#39;</span>
    
    <span class="n">distance_results</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="c1"># Process per ROI</span>
    <span class="k">for</span> <span class="n">roi_id</span><span class="p">,</span> <span class="n">roi_df</span> <span class="ow">in</span> <span class="n">features_df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">roi_column</span><span class="p">):</span>
        <span class="n">roi_edges</span> <span class="o">=</span> <span class="n">edges_df</span><span class="p">[</span><span class="n">edges_df</span><span class="p">[</span><span class="s1">&#39;roi_id&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="nb">str</span><span class="p">(</span><span class="n">roi_id</span><span class="p">)]</span>
        
        <span class="k">if</span> <span class="n">roi_edges</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
            <span class="k">continue</span>
        
        <span class="c1"># Get unique clusters</span>
        <span class="n">unique_clusters</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">roi_df</span><span class="p">[</span><span class="n">cluster_column</span><span class="p">]</span><span class="o">.</span><span class="n">dropna</span><span class="p">()</span><span class="o">.</span><span class="n">unique</span><span class="p">())</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">unique_clusters</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">continue</span>
        
        <span class="c1"># Create cell_id to cluster mapping</span>
        <span class="n">cell_to_cluster</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">roi_df</span><span class="p">[</span><span class="s1">&#39;cell_id&#39;</span><span class="p">],</span> <span class="n">roi_df</span><span class="p">[</span><span class="n">cluster_column</span><span class="p">]))</span>
        
        <span class="c1"># Compute distances for each cluster pair</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">cluster_a</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">unique_clusters</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">cluster_b</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">unique_clusters</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">i</span><span class="p">:</span>
                    <span class="k">continue</span>
                
                <span class="c1"># Find edges between these clusters</span>
                <span class="n">pair_distances</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">roi_edges</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
                    <span class="n">cell_a</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">edge</span><span class="p">[</span><span class="s1">&#39;cell_id_A&#39;</span><span class="p">])</span>
                    <span class="n">cell_b</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">edge</span><span class="p">[</span><span class="s1">&#39;cell_id_B&#39;</span><span class="p">])</span>
                    
                    <span class="n">cluster_a_edge</span> <span class="o">=</span> <span class="n">cell_to_cluster</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">cell_a</span><span class="p">)</span>
                    <span class="n">cluster_b_edge</span> <span class="o">=</span> <span class="n">cell_to_cluster</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">cell_b</span><span class="p">)</span>
                    
                    <span class="k">if</span> <span class="p">(</span><span class="n">cluster_a_edge</span> <span class="o">==</span> <span class="n">cluster_a</span> <span class="ow">and</span> <span class="n">cluster_b_edge</span> <span class="o">==</span> <span class="n">cluster_b</span><span class="p">)</span> <span class="ow">or</span> \
                       <span class="p">(</span><span class="n">cluster_a_edge</span> <span class="o">==</span> <span class="n">cluster_b</span> <span class="ow">and</span> <span class="n">cluster_b_edge</span> <span class="o">==</span> <span class="n">cluster_a</span><span class="p">):</span>
                        <span class="n">dist</span> <span class="o">=</span> <span class="n">edge</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;distance_um&#39;</span><span class="p">,</span> <span class="n">edge</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;distance&#39;</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">))</span>
                        <span class="n">pair_distances</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span>
                
                <span class="k">if</span> <span class="ow">not</span> <span class="n">pair_distances</span><span class="p">:</span>
                    <span class="k">continue</span>
                
                <span class="n">pair_distances</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pair_distances</span><span class="p">)</span>
                
                <span class="n">distance_results</span><span class="o">.</span><span class="n">append</span><span class="p">({</span>
                    <span class="s1">&#39;roi_id&#39;</span><span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="n">roi_id</span><span class="p">),</span>
                    <span class="s1">&#39;cluster_A&#39;</span><span class="p">:</span> <span class="n">cluster_a</span><span class="p">,</span>
                    <span class="s1">&#39;cluster_B&#39;</span><span class="p">:</span> <span class="n">cluster_b</span><span class="p">,</span>
                    <span class="s1">&#39;n_edges&#39;</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">pair_distances</span><span class="p">),</span>
                    <span class="s1">&#39;mean_distance&#39;</span><span class="p">:</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">pair_distances</span><span class="p">)),</span>
                    <span class="s1">&#39;median_distance&#39;</span><span class="p">:</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">pair_distances</span><span class="p">)),</span>
                    <span class="s1">&#39;std_distance&#39;</span><span class="p">:</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">pair_distances</span><span class="p">)),</span>
                    <span class="s1">&#39;min_distance&#39;</span><span class="p">:</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">pair_distances</span><span class="p">)),</span>
                    <span class="s1">&#39;max_distance&#39;</span><span class="p">:</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">pair_distances</span><span class="p">)),</span>
                    <span class="s1">&#39;q25_distance&#39;</span><span class="p">:</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">pair_distances</span><span class="p">,</span> <span class="mi">25</span><span class="p">)),</span>
                    <span class="s1">&#39;q75_distance&#39;</span><span class="p">:</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">pair_distances</span><span class="p">,</span> <span class="mi">75</span><span class="p">))</span>
                <span class="p">})</span>
    
    <span class="k">if</span> <span class="ow">not</span> <span class="n">distance_results</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
    
    <span class="n">results_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">distance_results</span><span class="p">)</span>
    
    <span class="c1"># Save output if path is provided</span>
    <span class="k">if</span> <span class="n">output_path</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">output_path</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">output_path</span><span class="p">)</span>
        <span class="n">results_df</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">output_path</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">results_df</span></div>



<div class="viewcode-block" id="dataframe_to_anndata">
<a class="viewcode-back" href="../../api_core.html#openimc.core.dataframe_to_anndata">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">dataframe_to_anndata</span><span class="p">(</span>
    <span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
    <span class="n">roi_id</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">roi_column</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;acquisition_id&#39;</span><span class="p">,</span>
    <span class="n">pixel_size_um</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="s1">&#39;ad.AnnData&#39;</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert OpenIMC DataFrame to AnnData format for squidpy analysis.</span>
<span class="sd">    </span>
<span class="sd">    This is the unified function used by both GUI and CLI.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        df: Feature dataframe with cells as rows</span>
<span class="sd">        roi_id: Optional ROI identifier to filter to a single ROI</span>
<span class="sd">        roi_column: Column name for ROI identifier</span>
<span class="sd">        pixel_size_um: Pixel size in micrometers for coordinate conversion</span>
<span class="sd">        </span>
<span class="sd">    Returns:</span>
<span class="sd">        AnnData object with spatial coordinates and features, or None if conversion fails</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="kn">import</span><span class="w"> </span><span class="nn">anndata</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">ad</span>
    <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ImportError</span><span class="p">(</span><span class="s2">&quot;anndata is required for AnnData-based spatial analysis. Install with: pip install anndata&quot;</span><span class="p">)</span>
    
    <span class="k">try</span><span class="p">:</span>
        <span class="c1"># Filter to specific ROI if provided</span>
        <span class="k">if</span> <span class="n">roi_id</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">roi_column</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">df</span><span class="p">[</span><span class="n">roi_column</span><span class="p">]</span> <span class="o">==</span> <span class="n">roi_id</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="k">if</span> <span class="n">df</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        
        <span class="c1"># Ensure required columns exist</span>
        <span class="n">required_cols</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;centroid_x&#39;</span><span class="p">,</span> <span class="s1">&#39;centroid_y&#39;</span><span class="p">,</span> <span class="s1">&#39;cell_id&#39;</span><span class="p">]</span>
        <span class="n">missing</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">required_cols</span> <span class="k">if</span> <span class="n">c</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">missing</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        
        <span class="c1"># Extract centroid coordinates</span>
        <span class="n">centroid_coords</span> <span class="o">=</span> <span class="n">df</span><span class="p">[[</span><span class="s1">&#39;centroid_x&#39;</span><span class="p">,</span> <span class="s1">&#39;centroid_y&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">values</span>
        
        <span class="c1"># Convert coordinates from pixels to micrometers</span>
        <span class="n">coords_um</span> <span class="o">=</span> <span class="n">centroid_coords</span> <span class="o">*</span> <span class="n">pixel_size_um</span>
        
        <span class="c1"># Identify feature columns (exclude metadata)</span>
        <span class="n">metadata_cols</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;cell_id&#39;</span><span class="p">,</span> <span class="s1">&#39;acquisition_id&#39;</span><span class="p">,</span> <span class="s1">&#39;acquisition_label&#39;</span><span class="p">,</span> <span class="s1">&#39;source_file&#39;</span><span class="p">,</span> 
            <span class="s1">&#39;source_well&#39;</span><span class="p">,</span> <span class="s1">&#39;label&#39;</span><span class="p">,</span> <span class="s1">&#39;centroid_x&#39;</span><span class="p">,</span> <span class="s1">&#39;centroid_y&#39;</span><span class="p">,</span> <span class="s1">&#39;cluster&#39;</span><span class="p">,</span>
            <span class="s1">&#39;cluster_phenotype&#39;</span><span class="p">,</span> <span class="s1">&#39;cluster_id&#39;</span><span class="p">,</span> <span class="s1">&#39;well&#39;</span><span class="p">,</span> <span class="s1">&#39;acquisition_name&#39;</span>
        <span class="p">}</span>
        
        <span class="c1"># Get intensity and morphology features</span>
        <span class="n">all_feature_cols</span> <span class="o">=</span> <span class="p">[</span><span class="n">col</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span> <span class="k">if</span> <span class="n">col</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">metadata_cols</span><span class="p">]</span>
        <span class="n">feature_cols</span> <span class="o">=</span> <span class="p">[</span><span class="n">col</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">all_feature_cols</span> <span class="k">if</span> <span class="n">col</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;_mean&#39;</span><span class="p">)]</span>
        
        <span class="c1"># Also include morphology features (they don&#39;t have _mean suffix)</span>
        <span class="n">morpho_names</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;area_um2&#39;</span><span class="p">,</span> <span class="s1">&#39;perimeter_um&#39;</span><span class="p">,</span> <span class="s1">&#39;equivalent_diameter_um&#39;</span><span class="p">,</span> <span class="s1">&#39;eccentricity&#39;</span><span class="p">,</span>
            <span class="s1">&#39;solidity&#39;</span><span class="p">,</span> <span class="s1">&#39;extent&#39;</span><span class="p">,</span> <span class="s1">&#39;circularity&#39;</span><span class="p">,</span> <span class="s1">&#39;major_axis_len_um&#39;</span><span class="p">,</span> <span class="s1">&#39;minor_axis_len_um&#39;</span><span class="p">,</span>
            <span class="s1">&#39;aspect_ratio&#39;</span><span class="p">,</span> <span class="s1">&#39;bbox_area_um2&#39;</span><span class="p">,</span> <span class="s1">&#39;touches_border&#39;</span><span class="p">,</span> <span class="s1">&#39;holes_count&#39;</span>
        <span class="p">}</span>
        <span class="n">morpho_cols</span> <span class="o">=</span> <span class="p">[</span><span class="n">col</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">all_feature_cols</span> <span class="k">if</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">morpho_names</span><span class="p">]</span>
        <span class="n">feature_cols</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">morpho_cols</span><span class="p">)</span>
        
        <span class="c1"># Create AnnData object</span>
        <span class="c1"># X: feature matrix (intensity and morphology features)</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">feature_cols</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="k">if</span> <span class="n">feature_cols</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">df</span><span class="p">),</span> <span class="mi">0</span><span class="p">))</span>
        
        <span class="c1"># obs: cell metadata</span>
        <span class="n">obs</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">metadata_cols</span> <span class="o">&amp;</span> <span class="nb">set</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">))]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">obs</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;cell_id&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
        
        <span class="c1"># obsm: spatial coordinates</span>
        <span class="n">obsm</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;spatial&#39;</span><span class="p">:</span> <span class="n">coords_um</span><span class="p">}</span>
        
        <span class="c1"># var: feature names</span>
        <span class="n">var</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="n">feature_cols</span><span class="p">)</span>
        
        <span class="c1"># Create AnnData</span>
        <span class="n">adata</span> <span class="o">=</span> <span class="n">ad</span><span class="o">.</span><span class="n">AnnData</span><span class="p">(</span><span class="n">X</span><span class="o">=</span><span class="n">X</span><span class="p">,</span> <span class="n">obs</span><span class="o">=</span><span class="n">obs</span><span class="p">,</span> <span class="n">var</span><span class="o">=</span><span class="n">var</span><span class="p">,</span> <span class="n">obsm</span><span class="o">=</span><span class="n">obsm</span><span class="p">)</span>
        
        <span class="c1"># Store cluster information in obs if available</span>
        <span class="n">cluster_col</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;cluster&#39;</span><span class="p">,</span> <span class="s1">&#39;cluster_phenotype&#39;</span><span class="p">,</span> <span class="s1">&#39;cluster_id&#39;</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                <span class="n">cluster_col</span> <span class="o">=</span> <span class="n">col</span>
                <span class="k">break</span>
        
        <span class="k">if</span> <span class="n">cluster_col</span><span class="p">:</span>
            <span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="s1">&#39;cluster&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">cluster_col</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
        
        <span class="k">return</span> <span class="n">adata</span>
        
    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="kn">import</span><span class="w"> </span><span class="nn">traceback</span>
        <span class="n">traceback</span><span class="o">.</span><span class="n">print_exc</span><span class="p">()</span>
        <span class="k">return</span> <span class="kc">None</span></div>



<div class="viewcode-block" id="build_spatial_graph_anndata">
<a class="viewcode-back" href="../../api_core.html#openimc.core.build_spatial_graph_anndata">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">build_spatial_graph_anndata</span><span class="p">(</span>
    <span class="n">features_df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span>
    <span class="n">method</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;kNN&quot;</span><span class="p">,</span>
    <span class="n">k_neighbors</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">20</span><span class="p">,</span>
    <span class="n">radius</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">pixel_size_um</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
    <span class="n">roi_column</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">roi_id</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">seed</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">42</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="s1">&#39;ad.AnnData&#39;</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Build spatial graph using squidpy and return AnnData objects per ROI.</span>
<span class="sd">    </span>
<span class="sd">    This function creates AnnData objects with spatial graphs built using squidpy.</span>
<span class="sd">    It&#39;s the unified function used by both GUI and CLI for AnnData-based spatial analysis.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        features_df: DataFrame with cell features, must contain &#39;centroid_x&#39; and &#39;centroid_y&#39;</span>
<span class="sd">        method: Graph construction method (&#39;kNN&#39;, &#39;Radius&#39;, or &#39;Delaunay&#39;)</span>
<span class="sd">        k_neighbors: Number of neighbors for kNN method (default: 20)</span>
<span class="sd">        radius: Radius in micrometers for radius-based method (required if method=&#39;Radius&#39;)</span>
<span class="sd">        pixel_size_um: Pixel size in micrometers for coordinate conversion (default: 1.0)</span>
<span class="sd">        roi_column: Column name for ROI grouping (e.g., &#39;acquisition_id&#39;). Auto-detected if None</span>
<span class="sd">        roi_id: Optional specific ROI to process. If None, processes all ROIs</span>
<span class="sd">        seed: Random seed for reproducibility (default: 42)</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        Dictionary mapping ROI ID to AnnData object with spatial graph built</span>
<span class="sd">    </span>
<span class="sd">    Raises:</span>
<span class="sd">        ImportError: If squidpy or anndata are not installed</span>
<span class="sd">        ValueError: If method is invalid or required parameters are missing</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="kn">import</span><span class="w"> </span><span class="nn">squidpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">sq</span>
        <span class="kn">import</span><span class="w"> </span><span class="nn">anndata</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">ad</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">scipy.spatial</span><span class="w"> </span><span class="kn">import</span> <span class="n">Delaunay</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">scipy</span><span class="w"> </span><span class="kn">import</span> <span class="n">sparse</span> <span class="k">as</span> <span class="n">sp</span>
    <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ImportError</span><span class="p">(</span>
            <span class="s2">&quot;squidpy, anndata, and scipy are required for AnnData-based spatial analysis. &quot;</span>
            <span class="s2">&quot;Install with: pip install squidpy anndata scipy&quot;</span>
        <span class="p">)</span>
    
    <span class="c1"># Validate method</span>
    <span class="k">if</span> <span class="n">method</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;kNN&#39;</span><span class="p">,</span> <span class="s1">&#39;Radius&#39;</span><span class="p">,</span> <span class="s1">&#39;Delaunay&#39;</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unknown graph method: </span><span class="si">{</span><span class="n">method</span><span class="si">}</span><span class="s2">. Must be &#39;kNN&#39;, &#39;Radius&#39;, or &#39;Delaunay&#39;&quot;</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;Radius&#39;</span> <span class="ow">and</span> <span class="n">radius</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;radius parameter is required for &#39;Radius&#39; method&quot;</span><span class="p">)</span>
    
    <span class="c1"># Determine ROI column</span>
    <span class="k">if</span> <span class="n">roi_column</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;acquisition_id&#39;</span><span class="p">,</span> <span class="s1">&#39;source_well&#39;</span><span class="p">,</span> <span class="s1">&#39;roi_id&#39;</span><span class="p">,</span> <span class="s1">&#39;roi&#39;</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">features_df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                <span class="n">roi_column</span> <span class="o">=</span> <span class="n">col</span>
                <span class="k">break</span>
    
    <span class="k">if</span> <span class="n">roi_column</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">roi_column</span> <span class="o">=</span> <span class="s1">&#39;acquisition_id&#39;</span>  <span class="c1"># Default</span>
    
    <span class="c1"># Get ROIs to process</span>
    <span class="k">if</span> <span class="n">roi_id</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">roi_ids</span> <span class="o">=</span> <span class="p">[</span><span class="n">roi_id</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">roi_ids</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">features_df</span><span class="p">[</span><span class="n">roi_column</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">())</span>
    
    <span class="n">anndata_dict</span> <span class="o">=</span> <span class="p">{}</span>
    
    <span class="k">for</span> <span class="n">current_roi_id</span> <span class="ow">in</span> <span class="n">roi_ids</span><span class="p">:</span>
        <span class="c1"># Convert dataframe to AnnData</span>
        <span class="n">adata</span> <span class="o">=</span> <span class="n">dataframe_to_anndata</span><span class="p">(</span>
            <span class="n">features_df</span><span class="p">,</span>
            <span class="n">roi_id</span><span class="o">=</span><span class="n">current_roi_id</span><span class="p">,</span>
            <span class="n">roi_column</span><span class="o">=</span><span class="n">roi_column</span><span class="p">,</span>
            <span class="n">pixel_size_um</span><span class="o">=</span><span class="n">pixel_size_um</span>
        <span class="p">)</span>
        
        <span class="k">if</span> <span class="n">adata</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">continue</span>
        
        <span class="c1"># Ensure cluster columns are categorical (required by squidpy)</span>
        <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;cluster&#39;</span><span class="p">,</span> <span class="s1">&#39;cluster_phenotype&#39;</span><span class="p">,</span> <span class="s1">&#39;cluster_id&#39;</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="n">col</span><span class="p">],</span> <span class="s1">&#39;cat&#39;</span><span class="p">):</span>
                    <span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="n">col</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;category&#39;</span><span class="p">)</span>
        
        <span class="c1"># Build spatial graph</span>
        <span class="n">coords</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">obsm</span><span class="p">[</span><span class="s1">&#39;spatial&#39;</span><span class="p">]</span>
        
        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;kNN&quot;</span><span class="p">:</span>
            <span class="c1"># Use squidpy for kNN</span>
            <span class="n">sq</span><span class="o">.</span><span class="n">gr</span><span class="o">.</span><span class="n">spatial_neighbors</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span> <span class="n">coord_type</span><span class="o">=</span><span class="s2">&quot;generic&quot;</span><span class="p">,</span> <span class="n">n_neighs</span><span class="o">=</span><span class="n">k_neighbors</span><span class="p">,</span> <span class="n">n_rings</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;Radius&quot;</span><span class="p">:</span>
            <span class="c1"># Radius is in micrometers, coordinates are in micrometers</span>
            <span class="n">sq</span><span class="o">.</span><span class="n">gr</span><span class="o">.</span><span class="n">spatial_neighbors</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span> <span class="n">coord_type</span><span class="o">=</span><span class="s2">&quot;generic&quot;</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span><span class="n">radius</span><span class="p">,</span> <span class="n">n_rings</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;Delaunay&quot;</span><span class="p">:</span>
            <span class="c1"># Delaunay triangulation - manual implementation</span>
            <span class="n">tri</span> <span class="o">=</span> <span class="n">Delaunay</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span>
            <span class="n">n_cells</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span>
            <span class="n">rows</span><span class="p">,</span> <span class="n">cols</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">simplex</span> <span class="ow">in</span> <span class="n">tri</span><span class="o">.</span><span class="n">simplices</span><span class="p">:</span>
                <span class="c1"># Each simplex has 3 vertices, create edges between all pairs</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">):</span>
                        <span class="n">rows</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">simplex</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">simplex</span><span class="p">[</span><span class="n">j</span><span class="p">]])</span>
                        <span class="n">cols</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">simplex</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">simplex</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span>
            
            <span class="c1"># Create sparse matrix</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">rows</span><span class="p">))</span>
            <span class="n">conn</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">((</span><span class="n">data</span><span class="p">,</span> <span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">)),</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">n_cells</span><span class="p">,</span> <span class="n">n_cells</span><span class="p">))</span>
            
            <span class="c1"># Store in AnnData format</span>
            <span class="n">adata</span><span class="o">.</span><span class="n">obsp</span><span class="p">[</span><span class="s1">&#39;spatial_connectivities&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">conn</span>
            
            <span class="c1"># Calculate distances</span>
            <span class="n">distances</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">):</span>
                <span class="n">dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">coords</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">coords</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                <span class="n">distances</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span>
            <span class="n">dist_matrix</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">((</span><span class="n">distances</span><span class="p">,</span> <span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="n">cols</span><span class="p">)),</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">n_cells</span><span class="p">,</span> <span class="n">n_cells</span><span class="p">))</span>
            <span class="n">adata</span><span class="o">.</span><span class="n">obsp</span><span class="p">[</span><span class="s1">&#39;spatial_distances&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dist_matrix</span>
        
        <span class="c1"># Verify graph was created</span>
        <span class="k">if</span> <span class="s1">&#39;spatial_connectivities&#39;</span> <span class="ow">in</span> <span class="n">adata</span><span class="o">.</span><span class="n">obsp</span><span class="p">:</span>
            <span class="n">anndata_dict</span><span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">current_roi_id</span><span class="p">)]</span> <span class="o">=</span> <span class="n">adata</span>
    
    <span class="k">return</span> <span class="n">anndata_dict</span></div>



<div class="viewcode-block" id="spatial_neighborhood_enrichment">
<a class="viewcode-back" href="../../api_core.html#openimc.core.spatial_neighborhood_enrichment">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">spatial_neighborhood_enrichment</span><span class="p">(</span>
    <span class="n">anndata_dict</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="s1">&#39;ad.AnnData&#39;</span><span class="p">],</span>
    <span class="n">cluster_key</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;cluster&quot;</span><span class="p">,</span>
    <span class="n">aggregation</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;mean&quot;</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute neighborhood enrichment using squidpy.</span>
<span class="sd">    </span>
<span class="sd">    This function computes neighborhood enrichment for each ROI and optionally aggregates results.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        anndata_dict: Dictionary mapping ROI ID to AnnData object with spatial graph</span>
<span class="sd">        cluster_key: Column name containing cluster labels (default: &quot;cluster&quot;)</span>
<span class="sd">        aggregation: Aggregation method for multiple ROIs (&quot;mean&quot; or &quot;sum&quot;, default: &quot;mean&quot;)</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        Dictionary with:</span>
<span class="sd">            - &#39;results&#39;: Dict mapping ROI ID to enrichment results</span>
<span class="sd">            - &#39;aggregated&#39;: Aggregated enrichment matrix (if multiple ROIs)</span>
<span class="sd">            - &#39;cluster_categories&#39;: List of cluster categories</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="kn">import</span><span class="w"> </span><span class="nn">squidpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">sq</span>
        <span class="kn">import</span><span class="w"> </span><span class="nn">anndata</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">ad</span>
    <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ImportError</span><span class="p">(</span><span class="s2">&quot;squidpy and anndata are required for neighborhood enrichment&quot;</span><span class="p">)</span>
    
    <span class="n">results</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">enrichment_matrices</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">roi_cluster_map</span> <span class="o">=</span> <span class="p">{}</span>
    
    <span class="k">for</span> <span class="n">roi_id</span><span class="p">,</span> <span class="n">adata</span> <span class="ow">in</span> <span class="n">anndata_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="s1">&#39;spatial_connectivities&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">adata</span><span class="o">.</span><span class="n">obsp</span><span class="p">:</span>
            <span class="k">continue</span>
        
        <span class="k">if</span> <span class="n">cluster_key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="k">continue</span>
        
        <span class="c1"># Ensure categorical</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="n">cluster_key</span><span class="p">],</span> <span class="s1">&#39;cat&#39;</span><span class="p">):</span>
            <span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="n">cluster_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="n">cluster_key</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;category&#39;</span><span class="p">)</span>
        
        <span class="c1"># Run neighborhood enrichment</span>
        <span class="n">sq</span><span class="o">.</span><span class="n">gr</span><span class="o">.</span><span class="n">nhood_enrichment</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span> <span class="n">cluster_key</span><span class="o">=</span><span class="n">cluster_key</span><span class="p">)</span>
        
        <span class="c1"># Extract matrix</span>
        <span class="n">enrichment_data</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">uns</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;nhood_enrichment&#39;</span><span class="p">,</span> <span class="p">{})</span>
        <span class="n">matrix</span> <span class="o">=</span> <span class="kc">None</span>
        
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">enrichment_data</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="k">if</span> <span class="s1">&#39;zscore&#39;</span> <span class="ow">in</span> <span class="n">enrichment_data</span><span class="p">:</span>
                <span class="n">matrix</span> <span class="o">=</span> <span class="n">enrichment_data</span><span class="p">[</span><span class="s1">&#39;zscore&#39;</span><span class="p">]</span>
            <span class="k">elif</span> <span class="s1">&#39;count&#39;</span> <span class="ow">in</span> <span class="n">enrichment_data</span><span class="p">:</span>
                <span class="n">matrix</span> <span class="o">=</span> <span class="n">enrichment_data</span><span class="p">[</span><span class="s1">&#39;count&#39;</span><span class="p">]</span>
            <span class="k">elif</span> <span class="s1">&#39;stat&#39;</span> <span class="ow">in</span> <span class="n">enrichment_data</span><span class="p">:</span>
                <span class="n">matrix</span> <span class="o">=</span> <span class="n">enrichment_data</span><span class="p">[</span><span class="s1">&#39;stat&#39;</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">enrichment_data</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="n">value</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                        <span class="n">matrix</span> <span class="o">=</span> <span class="n">value</span>
                        <span class="k">break</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">enrichment_data</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="n">matrix</span> <span class="o">=</span> <span class="n">enrichment_data</span>
        
        <span class="k">if</span> <span class="n">matrix</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="n">matrix</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">results</span><span class="p">[</span><span class="n">roi_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">adata</span>
            <span class="n">enrichment_matrices</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">roi_id</span><span class="p">,</span> <span class="n">matrix</span><span class="p">))</span>
            
            <span class="c1"># Get cluster categories</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="n">cluster_key</span><span class="p">],</span> <span class="s1">&#39;cat&#39;</span><span class="p">):</span>
                <span class="n">clusters</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="n">cluster_key</span><span class="p">]</span><span class="o">.</span><span class="n">cat</span><span class="o">.</span><span class="n">categories</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">clusters</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="n">cluster_key</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">())</span>
            <span class="n">roi_cluster_map</span><span class="p">[</span><span class="n">roi_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">clusters</span>
    
    <span class="c1"># Aggregate if multiple ROIs</span>
    <span class="n">aggregated_matrix</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">all_clusters_union</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">enrichment_matrices</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="c1"># Get union of all clusters</span>
        <span class="n">all_cluster_sets</span> <span class="o">=</span> <span class="p">[</span><span class="nb">set</span><span class="p">(</span><span class="n">clusters</span><span class="p">)</span> <span class="k">for</span> <span class="n">clusters</span> <span class="ow">in</span> <span class="n">roi_cluster_map</span><span class="o">.</span><span class="n">values</span><span class="p">()]</span>
        <span class="n">all_clusters_union</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">set</span><span class="p">()</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="o">*</span><span class="n">all_cluster_sets</span><span class="p">))</span> <span class="k">if</span> <span class="n">all_cluster_sets</span> <span class="k">else</span> <span class="p">[]</span>
        
        <span class="k">if</span> <span class="n">all_clusters_union</span><span class="p">:</span>
            <span class="c1"># Align all matrices to the union of clusters</span>
            <span class="n">aligned_matrices</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">n_clusters</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_clusters_union</span><span class="p">)</span>
            
            <span class="k">for</span> <span class="n">roi_id</span><span class="p">,</span> <span class="n">matrix</span> <span class="ow">in</span> <span class="n">enrichment_matrices</span><span class="p">:</span>
                <span class="n">roi_clusters</span> <span class="o">=</span> <span class="n">roi_cluster_map</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">roi_id</span><span class="p">)</span>
                
                <span class="k">if</span> <span class="n">roi_clusters</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="c1"># Create aligned matrix</span>
                    <span class="n">aligned_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">n_clusters</span><span class="p">,</span> <span class="n">n_clusters</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
                    
                    <span class="c1"># Map old indices to new indices</span>
                    <span class="n">cluster_to_new_idx</span> <span class="o">=</span> <span class="p">{</span><span class="n">clust</span><span class="p">:</span> <span class="n">idx</span> <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">clust</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">all_clusters_union</span><span class="p">)}</span>
                    
                    <span class="c1"># Fill in values where clusters overlap</span>
                    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">old_clust_i</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">roi_clusters</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">old_clust_i</span> <span class="ow">in</span> <span class="n">cluster_to_new_idx</span><span class="p">:</span>
                            <span class="n">new_i</span> <span class="o">=</span> <span class="n">cluster_to_new_idx</span><span class="p">[</span><span class="n">old_clust_i</span><span class="p">]</span>
                            <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">old_clust_j</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">roi_clusters</span><span class="p">):</span>
                                <span class="k">if</span> <span class="n">old_clust_j</span> <span class="ow">in</span> <span class="n">cluster_to_new_idx</span><span class="p">:</span>
                                    <span class="n">new_j</span> <span class="o">=</span> <span class="n">cluster_to_new_idx</span><span class="p">[</span><span class="n">old_clust_j</span><span class="p">]</span>
                                    <span class="n">aligned_matrix</span><span class="p">[</span><span class="n">new_i</span><span class="p">,</span> <span class="n">new_j</span><span class="p">]</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
                    
                    <span class="n">aligned_matrices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">aligned_matrix</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">aligned_matrices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">matrix</span><span class="p">)</span>
            
            <span class="c1"># Aggregate</span>
            <span class="n">stacked</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">aligned_matrices</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">aggregation</span> <span class="o">==</span> <span class="s1">&#39;mean&#39;</span><span class="p">:</span>
                <span class="n">aggregated_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">stacked</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c1"># sum</span>
                <span class="n">aggregated_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">stacked</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">aggregated_matrix</span> <span class="o">=</span> <span class="n">enrichment_matrices</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="n">enrichment_matrices</span> <span class="k">else</span> <span class="kc">None</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">enrichment_matrices</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">aggregated_matrix</span> <span class="o">=</span> <span class="n">enrichment_matrices</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">all_clusters_union</span> <span class="o">=</span> <span class="n">roi_cluster_map</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">enrichment_matrices</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="p">[])</span>
    
    <span class="k">return</span> <span class="p">{</span>
        <span class="s1">&#39;results&#39;</span><span class="p">:</span> <span class="n">results</span><span class="p">,</span>
        <span class="s1">&#39;aggregated&#39;</span><span class="p">:</span> <span class="n">aggregated_matrix</span><span class="p">,</span>
        <span class="s1">&#39;cluster_categories&#39;</span><span class="p">:</span> <span class="n">all_clusters_union</span>
    <span class="p">}</span></div>



<div class="viewcode-block" id="spatial_cooccurrence">
<a class="viewcode-back" href="../../api_core.html#openimc.core.spatial_cooccurrence">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">spatial_cooccurrence</span><span class="p">(</span>
    <span class="n">anndata_dict</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="s1">&#39;ad.AnnData&#39;</span><span class="p">],</span>
    <span class="n">cluster_key</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;cluster&quot;</span><span class="p">,</span>
    <span class="n">interval</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">100</span><span class="p">],</span>
    <span class="n">reference_cluster</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="s1">&#39;ad.AnnData&#39;</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute co-occurrence analysis using squidpy.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        anndata_dict: Dictionary mapping ROI ID to AnnData object with spatial graph</span>
<span class="sd">        cluster_key: Column name containing cluster labels (default: &quot;cluster&quot;)</span>
<span class="sd">        interval: List of distances in micrometers for co-occurrence analysis</span>
<span class="sd">        reference_cluster: Optional reference cluster for co-occurrence</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        Dictionary mapping ROI ID to AnnData object with co-occurrence results</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="kn">import</span><span class="w"> </span><span class="nn">squidpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">sq</span>
    <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ImportError</span><span class="p">(</span><span class="s2">&quot;squidpy is required for co-occurrence analysis&quot;</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">interval</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Co-occurrence analysis requires at least 2 distances in interval&quot;</span><span class="p">)</span>
    
    <span class="n">results</span> <span class="o">=</span> <span class="p">{}</span>
    
    <span class="k">for</span> <span class="n">roi_id</span><span class="p">,</span> <span class="n">adata</span> <span class="ow">in</span> <span class="n">anndata_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="s1">&#39;spatial_connectivities&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">adata</span><span class="o">.</span><span class="n">obsp</span><span class="p">:</span>
            <span class="k">continue</span>
        
        <span class="k">if</span> <span class="n">cluster_key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="k">continue</span>
        
        <span class="c1"># Ensure categorical</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="n">cluster_key</span><span class="p">],</span> <span class="s1">&#39;cat&#39;</span><span class="p">):</span>
            <span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="n">cluster_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="n">cluster_key</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;category&#39;</span><span class="p">)</span>
        
        <span class="c1"># Run co-occurrence analysis</span>
        <span class="n">sq</span><span class="o">.</span><span class="n">gr</span><span class="o">.</span><span class="n">co_occurrence</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span> <span class="n">cluster_key</span><span class="o">=</span><span class="n">cluster_key</span><span class="p">,</span> <span class="n">interval</span><span class="o">=</span><span class="n">interval</span><span class="p">)</span>
        
        <span class="n">results</span><span class="p">[</span><span class="n">roi_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">adata</span>
    
    <span class="k">return</span> <span class="n">results</span></div>



<div class="viewcode-block" id="spatial_autocorrelation">
<a class="viewcode-back" href="../../api_core.html#openimc.core.spatial_autocorrelation">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">spatial_autocorrelation</span><span class="p">(</span>
    <span class="n">anndata_dict</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="s1">&#39;ad.AnnData&#39;</span><span class="p">],</span>
    <span class="n">markers</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">aggregation</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;mean&quot;</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute spatial autocorrelation (Moran&#39;s I) using squidpy.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        anndata_dict: Dictionary mapping ROI ID to AnnData object with spatial graph</span>
<span class="sd">        markers: Optional list of marker names to analyze. If None, analyzes all features</span>
<span class="sd">        aggregation: Aggregation method for multiple ROIs (&quot;mean&quot; or &quot;sum&quot;, default: &quot;mean&quot;)</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        Dictionary with:</span>
<span class="sd">            - &#39;results&#39;: Dict mapping ROI ID to AnnData object with autocorrelation results</span>
<span class="sd">            - &#39;aggregated&#39;: Aggregated results (if multiple ROIs)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="kn">import</span><span class="w"> </span><span class="nn">squidpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">sq</span>
    <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ImportError</span><span class="p">(</span><span class="s2">&quot;squidpy is required for spatial autocorrelation&quot;</span><span class="p">)</span>
    
    <span class="n">results</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">moran_results</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">all_genes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    
    <span class="k">for</span> <span class="n">roi_id</span><span class="p">,</span> <span class="n">adata</span> <span class="ow">in</span> <span class="n">anndata_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="s1">&#39;spatial_connectivities&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">adata</span><span class="o">.</span><span class="n">obsp</span><span class="p">:</span>
            <span class="k">continue</span>
        
        <span class="c1"># Run spatial autocorrelation</span>
        <span class="k">if</span> <span class="n">markers</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">available_genes</span> <span class="o">=</span> <span class="p">[</span><span class="n">g</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">markers</span> <span class="k">if</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">adata</span><span class="o">.</span><span class="n">var_names</span><span class="p">]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">available_genes</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">sq</span><span class="o">.</span><span class="n">gr</span><span class="o">.</span><span class="n">spatial_autocorr</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;moran&quot;</span><span class="p">,</span> <span class="n">genes</span><span class="o">=</span><span class="n">available_genes</span><span class="p">)</span>
            <span class="n">all_genes</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">available_genes</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sq</span><span class="o">.</span><span class="n">gr</span><span class="o">.</span><span class="n">spatial_autocorr</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;moran&quot;</span><span class="p">)</span>
            <span class="n">var_names_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">adata</span><span class="o">.</span><span class="n">var_names</span><span class="p">)</span> <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">adata</span><span class="o">.</span><span class="n">var_names</span><span class="p">,</span> <span class="s1">&#39;__iter__&#39;</span><span class="p">)</span> <span class="k">else</span> <span class="p">[]</span>
            <span class="n">all_genes</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">var_names_list</span><span class="p">)</span>
        
        <span class="c1"># Extract results</span>
        <span class="n">moran_data</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">uns</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;moranI&#39;</span><span class="p">,</span> <span class="p">{})</span>
        
        <span class="c1"># Check if moran_data is not empty</span>
        <span class="n">has_data</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">moran_data</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
            <span class="n">has_data</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">moran_data</span><span class="o">.</span><span class="n">empty</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">moran_data</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="n">has_data</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">moran_data</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">moran_data</span><span class="p">,</span> <span class="s1">&#39;__len__&#39;</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">has_data</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">moran_data</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">):</span>
                <span class="n">has_data</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">has_data</span> <span class="o">=</span> <span class="n">moran_data</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">moran_data</span> <span class="o">!=</span> <span class="p">{}</span>
        
        <span class="k">if</span> <span class="n">has_data</span><span class="p">:</span>
            <span class="n">results</span><span class="p">[</span><span class="n">roi_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">adata</span>
            <span class="n">moran_results</span><span class="o">.</span><span class="n">append</span><span class="p">({</span>
                <span class="s1">&#39;adata&#39;</span><span class="p">:</span> <span class="n">adata</span><span class="p">,</span>
                <span class="s1">&#39;moranI&#39;</span><span class="p">:</span> <span class="n">moran_data</span>
            <span class="p">})</span>
    
    <span class="c1"># Aggregate results if multiple ROIs</span>
    <span class="n">aggregated_adata</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">moran_results</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">common_genes</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">all_genes</span><span class="p">)</span>
        <span class="n">I_values_agg</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">p_values_agg</span> <span class="o">=</span> <span class="p">[]</span>
        
        <span class="k">for</span> <span class="n">gene</span> <span class="ow">in</span> <span class="n">common_genes</span><span class="p">:</span>
            <span class="n">I_vals</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">p_vals</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">result</span> <span class="ow">in</span> <span class="n">moran_results</span><span class="p">:</span>
                <span class="n">moranI</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="s1">&#39;moranI&#39;</span><span class="p">]</span>
                
                <span class="c1"># Handle DataFrame format</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">moranI</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">gene</span> <span class="ow">in</span> <span class="n">moranI</span><span class="o">.</span><span class="n">index</span><span class="p">:</span>
                        <span class="n">I_val</span> <span class="o">=</span> <span class="n">moranI</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">gene</span><span class="p">,</span> <span class="s1">&#39;I&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="s1">&#39;I&#39;</span> <span class="ow">in</span> <span class="n">moranI</span><span class="o">.</span><span class="n">columns</span> <span class="k">else</span> <span class="kc">None</span>
                        <span class="n">p_val</span> <span class="o">=</span> <span class="n">moranI</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">gene</span><span class="p">,</span> <span class="s1">&#39;pval_norm&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="s1">&#39;pval_norm&#39;</span> <span class="ow">in</span> <span class="n">moranI</span><span class="o">.</span><span class="n">columns</span> <span class="k">else</span> <span class="kc">None</span>
                        <span class="k">if</span> <span class="n">I_val</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="n">I_vals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">I_val</span><span class="p">))</span>
                        <span class="k">if</span> <span class="n">p_val</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="n">p_vals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">p_val</span><span class="p">))</span>
                <span class="c1"># Handle dict format</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">moranI</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                    <span class="k">if</span> <span class="s1">&#39;I&#39;</span> <span class="ow">in</span> <span class="n">moranI</span> <span class="ow">and</span> <span class="s1">&#39;var_names&#39;</span> <span class="ow">in</span> <span class="n">moranI</span><span class="p">:</span>
                        <span class="n">var_names</span> <span class="o">=</span> <span class="n">moranI</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;var_names&#39;</span><span class="p">,</span> <span class="p">[])</span>
                        <span class="k">if</span> <span class="n">gene</span> <span class="ow">in</span> <span class="n">var_names</span><span class="p">:</span>
                            <span class="n">idx</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">var_names</span><span class="p">)</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">gene</span><span class="p">)</span>
                            <span class="n">I_vals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">moranI</span><span class="p">[</span><span class="s1">&#39;I&#39;</span><span class="p">][</span><span class="n">idx</span><span class="p">]</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">moranI</span><span class="p">[</span><span class="s1">&#39;I&#39;</span><span class="p">],</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">))</span> <span class="k">else</span> <span class="n">moranI</span><span class="p">[</span><span class="s1">&#39;I&#39;</span><span class="p">])</span>
                            <span class="k">if</span> <span class="s1">&#39;pval_norm&#39;</span> <span class="ow">in</span> <span class="n">moranI</span><span class="p">:</span>
                                <span class="n">p_vals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">moranI</span><span class="p">[</span><span class="s1">&#39;pval_norm&#39;</span><span class="p">][</span><span class="n">idx</span><span class="p">]</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">moranI</span><span class="p">[</span><span class="s1">&#39;pval_norm&#39;</span><span class="p">],</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">))</span> <span class="k">else</span> <span class="n">moranI</span><span class="p">[</span><span class="s1">&#39;pval_norm&#39;</span><span class="p">])</span>
            
            <span class="k">if</span> <span class="n">I_vals</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">aggregation</span> <span class="o">==</span> <span class="s1">&#39;mean&#39;</span><span class="p">:</span>
                    <span class="n">I_values_agg</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">I_vals</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>  <span class="c1"># sum</span>
                    <span class="n">I_values_agg</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">I_vals</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">p_vals</span><span class="p">:</span>
                    <span class="n">p_values_agg</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">p_vals</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">p_values_agg</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)</span>
        
        <span class="c1"># Create aggregated result</span>
        <span class="k">class</span><span class="w"> </span><span class="nc">TempAnnData</span><span class="p">:</span>
            <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">I_vals</span><span class="p">,</span> <span class="n">p_vals</span><span class="p">,</span> <span class="n">genes</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">uns</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="s1">&#39;moranI&#39;</span><span class="p">:</span> <span class="p">{</span>
                        <span class="s1">&#39;I&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">I_vals</span><span class="p">),</span>
                        <span class="s1">&#39;pval_norm&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">p_vals</span><span class="p">)</span> <span class="k">if</span> <span class="n">p_vals</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span>
                        <span class="s1">&#39;var_names&#39;</span><span class="p">:</span> <span class="n">genes</span>
                    <span class="p">}</span>
                <span class="p">}</span>
        
        <span class="n">aggregated_adata</span> <span class="o">=</span> <span class="n">TempAnnData</span><span class="p">(</span><span class="n">I_values_agg</span><span class="p">,</span> <span class="n">p_values_agg</span><span class="p">,</span> <span class="n">common_genes</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">moran_results</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">aggregated_adata</span> <span class="o">=</span> <span class="n">moran_results</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;adata&#39;</span><span class="p">]</span>
    
    <span class="k">return</span> <span class="p">{</span>
        <span class="s1">&#39;results&#39;</span><span class="p">:</span> <span class="n">results</span><span class="p">,</span>
        <span class="s1">&#39;aggregated&#39;</span><span class="p">:</span> <span class="n">aggregated_adata</span>
    <span class="p">}</span></div>



<div class="viewcode-block" id="spatial_ripley">
<a class="viewcode-back" href="../../api_core.html#openimc.core.spatial_ripley">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">spatial_ripley</span><span class="p">(</span>
    <span class="n">anndata_dict</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="s1">&#39;ad.AnnData&#39;</span><span class="p">],</span>
    <span class="n">cluster_key</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;cluster&quot;</span><span class="p">,</span>
    <span class="n">mode</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;L&quot;</span><span class="p">,</span>
    <span class="n">max_dist</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">50.0</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="s1">&#39;ad.AnnData&#39;</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute Ripley functions using squidpy.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        anndata_dict: Dictionary mapping ROI ID to AnnData object with spatial graph</span>
<span class="sd">        cluster_key: Column name containing cluster labels (default: &quot;cluster&quot;)</span>
<span class="sd">        mode: Ripley function mode (&quot;F&quot;, &quot;G&quot;, or &quot;L&quot;, default: &quot;L&quot;)</span>
<span class="sd">        max_dist: Maximum distance in micrometers (default: 50.0)</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        Dictionary mapping ROI ID to AnnData object with Ripley results</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="kn">import</span><span class="w"> </span><span class="nn">squidpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">sq</span>
    <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ImportError</span><span class="p">(</span><span class="s2">&quot;squidpy is required for Ripley analysis&quot;</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">mode</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;F&#39;</span><span class="p">,</span> <span class="s1">&#39;G&#39;</span><span class="p">,</span> <span class="s1">&#39;L&#39;</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid Ripley mode: </span><span class="si">{</span><span class="n">mode</span><span class="si">}</span><span class="s2">. Must be &#39;F&#39;, &#39;G&#39;, or &#39;L&#39;&quot;</span><span class="p">)</span>
    
    <span class="n">results</span> <span class="o">=</span> <span class="p">{}</span>
    
    <span class="k">for</span> <span class="n">roi_id</span><span class="p">,</span> <span class="n">adata</span> <span class="ow">in</span> <span class="n">anndata_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="s1">&#39;spatial_connectivities&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">adata</span><span class="o">.</span><span class="n">obsp</span><span class="p">:</span>
            <span class="k">continue</span>
        
        <span class="k">if</span> <span class="n">cluster_key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="k">continue</span>
        
        <span class="c1"># Ensure categorical</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="n">cluster_key</span><span class="p">],</span> <span class="s1">&#39;cat&#39;</span><span class="p">):</span>
            <span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="n">cluster_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="n">cluster_key</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;category&#39;</span><span class="p">)</span>
        
        <span class="c1"># Check cluster sizes and filter out clusters with &lt; 2 cells</span>
        <span class="n">cluster_counts</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="n">cluster_key</span><span class="p">]</span><span class="o">.</span><span class="n">value_counts</span><span class="p">()</span>
        <span class="n">valid_clusters</span> <span class="o">=</span> <span class="n">cluster_counts</span><span class="p">[</span><span class="n">cluster_counts</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">valid_clusters</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">continue</span>
        
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">valid_clusters</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">cluster_counts</span><span class="p">):</span>
            <span class="c1"># Filter adata to only include valid clusters</span>
            <span class="n">adata_filtered</span> <span class="o">=</span> <span class="n">adata</span><span class="p">[</span><span class="n">adata</span><span class="o">.</span><span class="n">obs</span><span class="p">[</span><span class="n">cluster_key</span><span class="p">]</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">valid_clusters</span><span class="p">)]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">adata_filtered</span><span class="o">.</span><span class="n">n_obs</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">adata</span> <span class="o">=</span> <span class="n">adata_filtered</span>
        
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># Run Ripley analysis</span>
            <span class="n">sq</span><span class="o">.</span><span class="n">gr</span><span class="o">.</span><span class="n">ripley</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span> <span class="n">cluster_key</span><span class="o">=</span><span class="n">cluster_key</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span> <span class="n">max_dist</span><span class="o">=</span><span class="n">max_dist</span><span class="p">)</span>
            <span class="n">results</span><span class="p">[</span><span class="n">roi_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">adata</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">ValueError</span><span class="p">,</span> <span class="ne">Exception</span><span class="p">)</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="c1"># Skip if insufficient samples</span>
            <span class="k">if</span> <span class="s2">&quot;n_neighbors&quot;</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="ow">or</span> <span class="s2">&quot;n_samples_fit&quot;</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">):</span>
                <span class="k">continue</span>
            <span class="k">raise</span>
    
    <span class="k">return</span> <span class="n">results</span></div>



<div class="viewcode-block" id="export_anndata">
<a class="viewcode-back" href="../../api_core.html#openimc.core.export_anndata">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">export_anndata</span><span class="p">(</span>
    <span class="n">anndata_dict</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="s1">&#39;ad.AnnData&#39;</span><span class="p">],</span>
    <span class="n">output_path</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Path</span><span class="p">],</span>
    <span class="n">combined</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Path</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Export AnnData objects to file(s).</span>
<span class="sd">    </span>
<span class="sd">    This is the unified export function used by both GUI and CLI.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        anndata_dict: Dictionary mapping ROI ID to AnnData object</span>
<span class="sd">        output_path: Path to output file (if combined=True) or directory (if combined=False)</span>
<span class="sd">        combined: If True, export as single combined file. If False, export separate files per ROI</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        Path to exported file(s)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="kn">import</span><span class="w"> </span><span class="nn">anndata</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">ad</span>
    <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ImportError</span><span class="p">(</span><span class="s2">&quot;anndata is required for AnnData export&quot;</span><span class="p">)</span>
    
    <span class="n">output_path</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">output_path</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">combined</span><span class="p">:</span>
        <span class="c1"># Export as single combined file</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">output_path</span><span class="o">.</span><span class="n">suffix</span><span class="p">:</span>
            <span class="n">output_path</span> <span class="o">=</span> <span class="n">output_path</span><span class="o">.</span><span class="n">with_suffix</span><span class="p">(</span><span class="s1">&#39;.h5ad&#39;</span><span class="p">)</span>
        
        <span class="n">adata_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">anndata_dict</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">adata_list</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">combined_adata</span> <span class="o">=</span> <span class="n">adata_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">combined_adata</span> <span class="o">=</span> <span class="n">ad</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">adata_list</span><span class="p">,</span> <span class="n">join</span><span class="o">=</span><span class="s1">&#39;outer&#39;</span><span class="p">,</span> <span class="n">index_unique</span><span class="o">=</span><span class="s1">&#39;-&#39;</span><span class="p">)</span>
        
        <span class="n">combined_adata</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">output_path</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">output_path</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Export as separate files per ROI</span>
        <span class="n">output_path</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">parents</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        
        <span class="k">for</span> <span class="n">roi_id</span><span class="p">,</span> <span class="n">adata</span> <span class="ow">in</span> <span class="n">anndata_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">file_path</span> <span class="o">=</span> <span class="n">output_path</span> <span class="o">/</span> <span class="sa">f</span><span class="s2">&quot;anndata_roi_</span><span class="si">{</span><span class="n">roi_id</span><span class="si">}</span><span class="s2">.h5ad&quot;</span>
            <span class="n">adata</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">file_path</span><span class="p">))</span>
        
        <span class="k">return</span> <span class="n">output_path</span></div>


</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Dean Tessone.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>